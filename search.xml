<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[iOS基础]]></title>
    <url>%2F2018%2F10%2F11%2FiOS%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[接上一个篇，iOS基础。以下答案均为自己想法，有一些答案没有往深处去挖，如有错误跪求指出。 给你瞅瞅什么是开局一刀，后面把你砍成渣！！！ @property的本质是什么？1实例变量+get方法+set方法,也就是说使用@property系统会自动生成setter和getter方法。 @property 后面可以有哪些修饰符？1nonatomic，atomic，strong，copy，retain，weak，assign，readonly，writeonly，readwrite。 接下来问题来了，strong和copy的区别？问完还可以问copy和mutablecopy区别？1源头不可变的strong和copy没区别，都是浅拷贝。源头可变的strong是浅，copy是深。其实这个很好记copy思想就是不能变。至于mutablecopy就是深，我可不管你能不能变。如果你还是不明白，你最好写一个小Demo去深入的看看结果。 如何让自己的类用 copy 修饰符？如何重写带 copy 关键字的 setter？12需声明该类遵从 NSCopying 协议实现 NSCopying 协议的方法。该协议只有一个方法:- (id)copyWithZone:(NSZone *)zone; weak和assign的区别？12weak修饰的变量无野指针，释放的同时置空，访问不会crash。但只能修饰OC的对象。assign可以用于非OC对象。 这个之后又是延伸问题weak是如何置空的？1runtime 对于 weak 对象会放入一个 hash 表中。 用 weak 指向的对象内存地址作为 key，当此对象的引用计数为0的时候会 dealloc，runtime调用clearDeallocating函数，假如 weak 指向的对象内存地址是a，那么就会以a为键， 在这个 weak 表中搜索，找到所有以a为键的 weak 对象，从而设置为 nil。 nonatomic和atomic的区别？123在声明的时候如果不写，那么默认是atomic。atomic线程安全，速度慢。系统生成的 getter/setter 会保证 get、set 操作的完整性，不受其他线程影响。比如，线程 A 的 getter 方法运行到一半，线程 B 调用了 setter：那么线程 A 的 getter 还是能得到一个完好无损的对象。如果多个线程同时操作 get、set 方法，最后 get 得到的值有多种可能。nonatomic线程不安全，速度快。如有两个线程访问同一个属性，会出现无法预料的结果 这些问好了还有其他的关键字一并都能引申出来 block和weak区别？123456781）block下循环引用的问题__block本身并不能避免循环引用，避免循环引用需要在 block 内部把 __block 修饰的obj置为nil__weak可以避免循环引用，但是其会导致外部对象释放了之后，block 内部也访问不到这个对象的问题，我们可以通过在 block 内部声明一个 __strong的变量来指向 weakObj，使外部对象既能在 block 内部保持住，又能避免循环引用的问题2）__block 与 __weak 功能上的区别。__block 会持有该对象，即使超出了该对象的作用域，该对象还是会存在的，直到 block 对象从堆上销毁；而__weak 仅仅是将该对象赋值给 weak 对象，当该对象销毁时，weak 对象将指向nil；__block 可以让 block 修改局部变量，而 __weak 不能。另外，MRC中 __block 是不会引起 retain；但在ARC中 __block 则会引起 retain。所以ARC中应该使用 __weak。 block本质是什么？1其实 Block 的本质是带有函数执行上下文环境的结构体，其中包含被调函数指针 block截获变量的特性应该怎样解释？1__block 所起到的作用就是只要观察到该变量被 block 所持有，就将“外部变量”在栈中的内存地址放到了堆中 block和delegate区别？123451）delegate 运行成本低，block 运行成本高。block 出栈需要将使用的数据从栈内存拷贝到堆内存，使用完或者 block 置 nil 后被消除。delegate 只是保存了一个对象的指针，直接回调，没有额外消耗。2）delegate 是 weak 弱引用；block 是 copy 修饰，强引用。delegate 更安全些，block 容易引起循环引用。3）block 直接访问上下文，块和块实现在同一个地方，代码组织更加连贯。delegate 声明和方法分离开来，代码的连贯性不是很好。 有可能还会引出以下问题； block种类？123_NSConcreteGlobalBlock 全局的静态 block，不会访问外部局部变量。_NSConcreteMallocBlock 保存在堆中的 block，当引用计数为 0 时会被销毁。_NSConcreteStackBlock 保存在栈中的 block，当函数返回时会被销毁。 delegate和Notification的区别？1水平有限，我逛了一圈唯一发现的的就是1对1，1对多的不同，外加就是效率上 delegate 比较高，还有就是使用的时候看紧密程度，如果高就用 delegate 否则用 Notification，多线程里一般会用 Notification。 NSNotificationCenter的原理？12NSNotificatinonCenter 是使用观察者模式来实现的用于跨层传递消息，用来降低耦合度。NSNotificatinonCenter 用来管理通知，将观察者注册到 NSNotificatinonCenter 的通知调度表中，然后发送通知时利用标识符 name 和 object 识别出调度表中的观察者，然后调用相应的观察者的方法，即传递消息（在Objective-C中对象调用方法，就是传递消息，消息有 name 或者 selector，可以接受参数，而且可能有返回值），如果是基于 block 创建的通知就调用 NSNotification 的 block。 Notification使用的时候要注意什么？12Notification 使用的时候 add 和 remove 要成对的写。如果 add 之后没有 remove，那么你下次进来的时候，会通知2次。还有同名的注册多少次，他的执行代码就会执行多少次，但是移除的时候会一次性全部移除。 很好提到了观察者模式，来吧继续下面的 KVC和KVO？这个牛逼的，你想解释起来，那真是长篇大论，能说好久。12345KVC 通过 Key 名直接访问对象的属性，或者给对象的属性赋值。日常使用的地方：动态地取值和设值，访问和修改私有变量，Model 和字典转换，修改一些控件的内部属性KVO 其基本思想是，对目标对象的某属性添加观察，当该属性发生变化时，通过触发观察者对象实现的 KVO 接口方法，来自动的通知观察者。日常使用的地方：你用MVVM嘛？ KVO原理？12KVO 是通过 isa-swizzling 实现的。基本的流程就是编译器自动为被观察对象创造一个派生类，并将被观察对象的 isa 指向这个派生类。如果用户注册了对某此目标对象的某一个属性的观察，那么此派生类会重写这个方法，并在其中添加进行通知的代码。Objective-C 在发送消息的时候，会通过 isa 指针找到当前对象所属的类对象。而类对象中保存着当前对象的实例方法，因此在向此对象发送消息时候，实际上是发送到了派生类对象的方法。由于编译器对派生类的方法进行了 override，并添加了通知代码，因此会向注册的对象发送通知。注意派生类只重写注册了观察者的属性方法。 em？？？解释的迷迷糊糊一知半解，来来来咱们继续runtime走起！ 什么是runtime？1运行时，运行的时候决定具体要干什么 嗯，字面意思，大家都知道，继续！！！ 你都在什么地方使用过runtime1分类添加属性，方法添加或替换。 runtime怎么添加属性、方法等1class_addIvar，class_addMethod，class_addProperty，class_addProtocol，class_replaceProperty runtime如何通过selector找到对应的IMP地址？1类对象中有类方法和实例方法的列表，列表中记录着方法的名词、参数和实现，而selector本质就是方法名称，runtime通过这个方法名称就可以在列表中找到该方法对应的实现。还有缓存机制别忘了。 go on永不止步 消息机制方法调用流程？12345对象方法：(保存到类对象的方法列表) ，类方法：(保存到元类(Meta Class)中方法列表)。1）OC 在向一个对象发送消息时，runtime 库会根据对象的 isa 指针找到该对象对应的类或其父类中查找方法。2）注册方法编号（这里用方法编号的好处，可以快速查找）。3）根据方法编号去查找对应方法。4）找到只是最终函数实现地址，根据地址去方法区调用对应函数。 一波未平一波又起 消息转发？或者 _objc_msgForward 干什么的？12345当向一个对象发送一条消息，但它并没有实现的时候，_objc_msgForward 会尝试做消息转发。消息转发的过程会调用几个方法1）resolveInstanceMethod 是否动态的添加一个方法，添加提前结束消息转发，否则，继续执行2）forwardingTargetForSelector 诶，兄弟有人能帮我实现不？转发给另一个对象有，提前结束，否则，继续执行3）调用 methodSignatureForSelector 获取方法签名后，判断返回类型信息是否正确，再调用 forwardInvocation 执行 NSInvocation 对象，并将结果返回。如果对象没实现 methodSignatureForSelector 方法，进入最后一步。4）doesNotRecognizeSelector 没人管！ 是不是感觉到什么了，嘿嘿嘿 runtime 完事了，是不是要 runloop 了，在然后估计就是多线程 什么是 runloop ？12 runloop的mode作用是什么？12 什么地方使用过runloop？12 嗯这里可以引申出一个定时器的问题 NSTimer使用时需要注意什么12 runloop 和线程有什么关系？12 GCD和NSOperationQueue的区别？12 队列？12 GCD中dispatch_barrier_async做什么的？12 如何用GCD同步若干个异步调用？12 这块就进入了锁的知识 如何使用队列来避免资源抢夺？12 苹果为什么要废弃dispatch_get_current_queue？1容易造成死锁 我要去面试了，回来继续写！！！]]></content>
      <tags>
        <tag>-iOS基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据算法]]></title>
    <url>%2F2018%2F10%2F10%2F%E6%95%B0%E6%8D%AE%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[最近面试，被虐的很惨，实话实说，日常开发的东西基本上都会，有些不会的直接在stackoverflow上随便找找基本上都可以解决问题。面试的时候很多都是基础，平时遇见问题，google一下就带过了，也不会特意的背代码，很多问题都是碰见过，能解决，具体过程是真的忘了。所以有了以下这篇文章，想来一篇算法的，在来一份基础面试题，再之后写一篇面试的小问题吧。还有有一些答案不是最好的如果您有更好的，请给我留言，大家一起进步。—–来自一个非计算机专业的小白整理，请勿嘲笑。 1、交换A和B两个值1234567891011121314151617用中间参数void swap(int a, int b) &#123; int temp = a; a = b; b = temp;&#125;不用中间参数void swap(int a, int b) &#123; a = a + b; b = a - b; a = a - b;&#125;void swap(int a, int b) &#123; a = a ^ b; b = a ^ b; a = a ^ b;&#125; 2、模拟栈操作栈是一种数据结构，特点：先进后出1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950栈最多能保存1024个数据static int data[1024];目前已经放了多少个数static int count = 0;数据入栈 pushvoid push(int x) &#123; 防止数组越界 assert(!full()); data[count++] = x;&#125;数据出栈 popint pop() &#123; assert(!empty()); return data[--count];&#125;查看栈顶元素 topint top() &#123; assert(!empty()); return data[count-1];&#125;查询栈满 fullbool full() &#123; if(count &gt;= 1024) &#123; return 1; &#125; return 0;&#125;查询栈空 emptybool empty() &#123; if(count &lt;= 0) &#123; return 1; &#125; return 0;&#125;int main() &#123; 入栈 for (int i = 1; i &lt;= 10; i++) &#123; push(i); &#125; 出栈 while(!empty()) &#123; 栈顶元素 printf(&quot;%d &quot;, top()); 出栈 pop(); &#125; printf(&quot;\n&quot;); return 0;&#125; 3、排序冒泡排序最差时间复杂度 O(n^2)平均时间复杂度 O(n^2)1234567891011- (void)bubbleAscendingOrderSortWithArray:(NSMutableArray *)arr &#123; for (int i = 0; i &lt; arr.count; i++) &#123; for (int j = 0; j &lt; arr.count - 1 - i;j++) &#123; if ([arr[j+1] intValue] &lt; [arr[j] intValue]) &#123; int temp = [arr[j] intValue]; arr[j] = arr[j + 1]; arr[j + 1] = [NSNumber numberWithInt:temp]; &#125; &#125; &#125;&#125; 选择排序平均时间复杂度：O(n^2)平均空间复杂度：O(1)123456789101112131415- (void)selectionAscendingOrderSortWithArray:(NSMutableArray *)arr &#123; for (int i = 0; i &lt; arr.count; i ++) &#123; int index = i; for (int j = i + 1; j &lt; arr.count; j ++) &#123; if ([arr[index] intValue] &gt; [arr[j] intValue]) &#123; index = j; &#125; &#125; if(index != i) &#123; int temp = [arr[i] intValue]; arr[i] = arr[index]; arr[index] = [NSNumber numberWithInt:temp]; &#125; &#125;&#125; 插入排序平均时间复杂度：O(n^2)平均空间复杂度：O(1)123456789- (void)insertionAscendingOrderSort:(NSMutableArray *)arr &#123; for (int i = 1; i &lt; arr.count; i ++) &#123; int temp = [arr[i] intValue]; for (int j = i - 1; j &gt;= 0 &amp;&amp; temp &lt; [arr[j] intValue]; j --) &#123; arr[j + 1] = arr[j]; arr[j] = [NSNumber numberWithInteger:temp]; &#125; &#125;&#125; 快速排序平均时间复杂度：O(n^2)平均空间复杂度：O(nlogn) O(nlogn)~O(n^2)123456789101112131415161718192021- (void)quickSortArray:(NSMutableArray *)array withLeftIndex:(NSInteger)leftIndex andRightIndex:(NSInteger)rightIndex &#123; if (leftIndex &gt;= rightIndex) &#123; return ; &#125; NSInteger i = leftIndex; NSInteger j = rightIndex; NSInteger key = [array[i] intValue]; while (i &lt; j) &#123; while (i &lt; j &amp;&amp; [array[j] intValue] &gt;= key) &#123; j--; &#125; array[i] = array[j]; while (i &lt; j &amp;&amp; [array[i] intValue] &lt;= key) &#123; i++; &#125; array[j] = array[i]; &#125; array[i] = @(key); [self quickSortArray:array withLeftIndex:leftIndex andRightIndex:i - 1]; [self quickSortArray:array withLeftIndex:i + 1 andRightIndex:rightIndex];&#125; 希尔排序12 4、逆序字符串123456789101112131415161718192021222324不开辟空间新建字符串char* Reverse(char* s) &#123; char* q = s ; while( *q++ ) ; q -= 2 ; char* p = newchar[sizeof(char) * (q - s + 2)] ; char* r = p ; while(q &gt;= s) *p++ = *q-- ; *p = &apos;\0&apos; ; return r ;&#125;中间字符串- (NSString*)reverseWordsInString:(NSString*)oldStr &#123; NSMutableString *newStr = [[NSMutableString alloc] initWithCapacity:oldStr.length]; for (int i = oldStr.length - 1; i &gt;= 0; i --) &#123; unichar character = [oldStr characterAtIndex:i]; [newStr appendFormat:@&quot;%c&quot;,character]; &#125; return newStr;&#125; 5、链表翻转123456789101112131415161718192021node* reverseList(node* H) &#123; if (H == NULL || H-&gt;next == NULL) //链表为空或者仅1个数直接返回 return H; node* p = H, *newH = NULL; while (p != NULL) //一直迭代到链尾 &#123; node* tmp = p-&gt;next; //暂存p下一个地址，防止变化指针指向后找不到后续的数 p-&gt;next = newH; //p-&gt;next指向前一个空间 newH = p; //新链表的头移动到p，扩长一步链表 p = tmp; //p指向原始链表p指向的下一个空间 &#125; return newH; &#125;递归方式node* In_reverseList(node* H) &#123; if (H == NULL || H-&gt;next == NULL) //链表为空直接返回，而H-&gt;next为空是递归基 return H; node* newHead = In_reverseList(H-&gt;next); //一直循环到链尾 H-&gt;next-&gt;next = H; //翻转链表的指向 H-&gt;next = NULL; //记得赋值NULL，防止链表错乱 return newHead; //新链表头永远指向的是原链表的链尾&#125; 6、求最大公约数1234567891011121314int gcd(int a, int b) &#123; int temp = 0; if (a &lt; b) &#123; temp = a; a = b; b = temp; &#125; while (b != 0) &#123; temp = a % b; a = b; b = temp; &#125; return a;&#125; 7、从1亿个浮点数里找出最大的10个第一想法都是排序之后再取前10个，但是呢效率不行。本人第二想法就是取前十个排序，在从剩下的一个一个替换掉，最后得到10个最大的数。12345678910- (void)findMaxNum:(NSMutableArray *)arr &#123; NSMutableArray * myArr = [[NSMutableArray alloc] initWithArray:[arr subarrayWithRange:NSMakeRange(0, 10)]]; [self quickSortArray:myArr withLeftIndex:0 andRightIndex:myArr.count - 1]; for (int i = 10; i &lt; arr.count - 1; i++) &#123; if ([arr[i] intValue] &gt; [myArr[0] intValue]) &#123; myArr[0] = arr[i]; [self quickSortArray:myArr withLeftIndex:0 andRightIndex:myArr.count - 1]; &#125; &#125;&#125; 8、数组去重如果是OC的话，可以用NSSet的唯一性来去掉重复的字段。还有一些系统提供的方法，还有谓词搜索筛选。1234567891011121314151617- (void)findRepeatNum:(NSMutableArray *)arr &#123; NSMutableArray *myArr = [NSMutableArray array]; for (int i = 0; i &lt; arr.count; i++) &#123; BOOL isHave = NO; for (int j = 0; j &lt; myArr.count; j++) &#123; if ([arr[i] intValue] == [myArr[j] intValue]) &#123; isHave = YES; break; &#125; else &#123; isHave = NO; &#125; &#125; if (!isHave) &#123; [myArr addObject:arr[i]]; &#125; &#125;&#125; 9、二分法查找二分只适用于有序的数组查找12345678910111213141516171819202122232425- (NSInteger)binarySearch:(NSArray *)array target:(NSInteger)target &#123; if (array.count == 0) &#123; return -1; &#125; NSInteger start = 0; NSInteger end = array.count - 1; NSInteger mid = 0; while (start + 1 &lt; end) &#123; mid = start + (end - start) / 2; if ([array[mid] integerValue] == target) &#123; return mid; &#125; else if ([array[mid] integerValue] &lt; target) &#123; start = mid; &#125; else &#123; end = mid; &#125; &#125; if ([array[start] integerValue] == target) &#123; return start; &#125; if ([array[end] integerValue] == target) &#123; return end; &#125; return -1;&#125; 10、求最大值和最小值，这个太简单了。。。第一个为最大值或最小值，一个for循环比下去。 11、二叉树遍历先序遍历-中左右中序遍历-左中右后续遍历-左右中 算法的我就先整理几个，后续会新增一些面试过程遇到的。]]></content>
      <tags>
        <tag>-iOS进阶</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ReactNative]]></title>
    <url>%2F2017%2F09%2F10%2FReactNative%2F</url>
    <content type="text"><![CDATA[ReactNative内容。此文只献给那些没用过，还在排坑的小伙伴们。有错误内容还请指出。 集成到现有原生应用如过你还没有安装过或者没使用过，去中文网查看相关流程。 pod文件内加入基本的配置1234567891011121314151617pod 'React', :path =&gt; './RNComponent/node_modules/react-native', :subspecs =&gt; [ 'Core', 'CxxBridge', # 如果RN版本 &gt;= 0.47则加入此行 'DevSupport', # 如果RN版本 &gt;= 0.43，则需要加入此行才能开启开发者菜单 'RCTText', 'RCTNetwork', 'RCTWebSocket', # 调试功能需要此模块 'RCTAnimation', # FlatList和原生动画功能需要此模块 #在这里继续添加你所需要的其他RN模块]#如果你的RN版本 &gt;= 0.42.0，则加入下面这行pod 'yoga', :path =&gt; './RNComponent/node_modules/react-native/ReactCommon/yoga'#如果RN版本 &gt;= 0.45则加入下面三个第三方编译依赖pod 'DoubleConversion', :podspec =&gt; './RNComponent/node_modules/react-native/third-party-podspecs/DoubleConversion.podspec'pod 'glog', :podspec =&gt; './RNComponent/node_modules/react-native/third-party-podspecs/glog.podspec'pod 'Folly', :podspec =&gt; './RNComponent/node_modules/react-native/third-party-podspecs/Folly.podspec' 具体内容我就不说了。记录下我的错误问题。 version0.57.1版本的时候出现问题记录：[!] CocoaPods could not find compatible versions for pod “Folly”:In Podfile:Folly (from ./RNComponent/node_modules/react-native/third-party-podspecs/Folly.podspec) Specs satisfying the Folly (from./RNComponent/node_modules/react-native/third-party-podspecs/Folly.podspec) dependency were found, but they required a higher minimum deployment target. 三个第三方编译依赖Folly需要9.0以上：修改platform :ios,’9.0’they required a higher minimum deployment target.这句话提示怎么做。 如果你使用MLeaksFinder间接导入FBRetainCycleDetector。运行app会报错Array has incomplete element type ‘struct rcd_rebinding’ 原因是RN和FBRetainCycleDetector里都有fishhook.cfishhook.h把FBRetainCycleDetector里的修改成rcd_fishhook.crcd_fishhook.h或者，坐等facebook更新喽。]]></content>
      <tags>
        <tag>-iOS进阶</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ijkplayer]]></title>
    <url>%2F2017%2F09%2F10%2Fijkplayer%2F</url>
    <content type="text"><![CDATA[生活不易啊，继续学习啊ijkplayer。 B站GitHub，先下载个ijkplayer吧。 默认为最少支持, 如果足够你使用, 可以跳过这一步. 否则可以改为以下配置:module-default.sh 更多的编解码器/格式module-lite-hevc.sh 较少的编解码器/格式(包括hevc)module-lite.sh 较少的编解码器/格式(默认情况) 进入 config 目录cd config删除当前的 module.sh 文件rm module.sh可根据需要替换为module-default.sh, module-lite-hevc.sh, module-lite.sh创建软链接 module.sh 指向 module-lite-hevc.shln -s module-lite-hevc.sh module.sh em…编译，过程需要下载ffmpeg，毕竟基于ffmpeg嘛。打开终端，cd到ijkplayer-master，执行 ./init-ios.sh 时间可能会有点长。 支持https设置获取 openssl 并初始化./init-ios-openssl.sh 启用 openssl 组件方法echo ‘export COMMON_FF_CFG_FLAGS=”$COMMON_FF_CFG_FLAGS –enable-openssl”‘ &gt;&gt; ../config/module.sh或者vim ../config/module.shexport COMMON_FF_CFG_FLAGS=”$COMMON_FF_CFG_FLAGS –enable-openssl” cd ios./compile-ffmpeg.sh clean./compile-openssl.sh all过程是屏幕一顿飞，会出现警告，别慌！！！如果不需要https以上步骤可以省略掉。 执行 ./compile-ffmpeg.sh all 中间可能会卡顿一下，然后一顿滚屏，别停止了喔。 ./libavutil/arm/asm.S:50:9: error: unknown directive.arch armv7-a^ 如果出这个错误。在 compile-ffmpeg.sh 中删除 armv7FF_ALL_ARCHS_IOS8_SDK=”arm64 i386 x86_64”再重新执行: ./compile-ffmpeg.sh all 然后运行IJKMediaDemo。把libcrypto.a和libssl.a加进去。 应该就可以使用了。只能看看在线的给你们一个地址试试吧，http://clips.vorwaerts-gmbh.de/big_buck_bunny.mp4 https://gcs-vimeo.akamaized.net/exp=1536608263~acl=%2A%2F623685558.mp4%2A~hmac=ac4bea3eee7fd318322ce65b675f742017a84c294aa0ac57f8480aa9bfd80037/vimeo-prod-skyfire-std-us/01/2670/7/188350983/623685558.mp4 打包 framwork完成最后的工作！！！open IJKMediaPlayer/IJKMediaPlayer.xcodeproj 配置 Release 模式打包真机 framework如果之前删除了armv7，注释include “armv7/avconfig.h”command+b打包模拟器 frameworkcommand+b在Products里有IJKMediaFramework.framework，右键，show in Finder 合并 framework cd 到 Products目录下lipo -create 真机framework路径 模拟器framework路径 -output 合并的文件路径 lipo -create Release-iphoneos/IJKMediaFramework.framework/IJKMediaFramework Release-iphonesimulator/IJKMediaFramework.framework/IJKMediaFramework -output IJKMediaFramework 生成了IJKMediaFramework文件，拖入真机或模拟器的framework中，替换掉之前的IJKMediaFramework，之后IJKMediaFramework.framework可以导入工程了。 添加下列依赖到工程libc++.tbdlibz.tbdlibbz2.tbdAudioToolbox.frameworkUIKit.frameworkCoreGraphics.frameworkAVFoundation.frameworkCoreMedia.frameworkCoreVideo.frameworkMediaPlayer.frameworkMobileCoreServices.frameworkOpenGLES.frameworkQuartzCore.frameworkVideoToolbox.framework 在Header Search Paths加入头文件的路径。 另外如果要支持rtsp在 ijkplayer-master 下的 config 中，打开 module-lite.sh将 export COMMON_FF_CFG_FLAGS=”$COMMON_FF_CFG_FLAGS –disable-protocol=rtp”修改为 export COMMON_FF_CFG_FLAGS=”$COMMON_FF_CFG_FLAGS –enable-protocol=rtp”并添加 export COMMON_FF_CFG_FLAGS=”$COMMON_FF_CFG_FLAGS –enable-demuxer=rtsp”export COMMON_FF_CFG_FLAGS=”$COMMON_FF_CFG_FLAGS –enable-decoder=mjpeg”export COMMON_FF_CFG_FLAGS=”$COMMON_FF_CFG_FLAGS –enable-demuxer=mjpeg”然后命令行执行:rm module.shln -s module-lite.sh module.sh在执行cd到ios那步。]]></content>
      <tags>
        <tag>-iOS进阶</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Cocoa Touch]]></title>
    <url>%2F2017%2F08%2F20%2FCocoa%20Touch%2F</url>
    <content type="text"><![CDATA[Cocoa Touch就是指Foundation框架和UIKit框架。 系统最上层的，编写代码的时候，先看看这层提供的技术是否能满足你的需求，如果能，就用。不行在往下层去搞。 Cocoa Touch都有啥 Message UI提供了App集成邮件与短信的支持。支持包括在App界面中弹出一个视图控制器界面。可以在该视图控制器中填入接收者，主题，主要内容和任意你想包含在信息里的附件。在弹出该视图控制器后，用户可以选择在发送之前对其做出编辑。 Address Book UI一个Object-C编程接口，用来显示创建新联系人和编辑已经存在联系人信息的标准系统联系人界面。该框架简化了在App中显示联系人信息的操作，同时保证所有App的联系人界面在同一平台上都相同。 EventKit UI提供了可以弹出查看和编辑日程相关事件的标准系统界面的视图控制器。该框架建立在EventKit框架的事件相关数据之上。 GameKit实现了对Game Centre的支持，Game Center让用户可以在线分享游戏相关数据。 iAd让App实现横幅广告的展示。广告会嵌入到你的交互界面的标准视图中，并在需要的时候弹出。 MapKit提供可嵌入到App的用户界面中的可拖拽地图。可以使用该框架来自定义地图的内容与外观。 NotificationCenter提供创建在通知中心里显示信息的小部件的功能。 PushKit提供VoIP App的注册使用支持。该框架替代了之前注册VoIP App的API。 UIKit提供了实现绘图和事件驱动App的重要基础。]]></content>
      <tags>
        <tag>-iOS进阶</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[离屏渲染问题]]></title>
    <url>%2F2017%2F04%2F02%2FGPU%E7%A6%BB%E5%B1%8F%E6%B8%B2%E6%9F%93%2F</url>
    <content type="text"><![CDATA[这个是我没事的时候在Stackoverflow瞎溜达时候看的 什么是离屏渲染？ GPU了解下？ OpenGL的中，GPU屏幕渲染有两种方式。屏幕渲染（当前屏幕渲染）指的是GPU的渲染操作是在当前用于显示的屏幕缓冲区进行。离屏渲染（离屏渲染）指的是在GPU在当前屏幕缓冲区以外开辟一个缓冲区进行渲染操作。当发生离屏的时候，可能导致FPS下降，说白了，卡顿。人眼的辨识是30+ 什么时候会发生离屏渲染 光栅化、遮罩、阴影、抗锯齿、不透明、复杂形状设置圆角等等，所以新建的空间如果能透明就透明。 怎么检测呢？Instruments的Core Animation工具中有几个和离屏渲染相关的检查选项：Color Offscreen-Rendered Yellow开启后会把那些需要离屏渲染的图层高亮成黄色，这就意味着黄色图层可能存在性能问题。Color Hits Green and Misses Red 更新下，改版了新的Xcode（Debug）-（View Debugging）-（Rendering）-（Color Offscreen-Rendered Yellow）]]></content>
      <tags>
        <tag>-iOS进阶</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[捕获Crash]]></title>
    <url>%2F2017%2F03%2F09%2FCrash%E6%94%B6%E9%9B%86%2F</url>
    <content type="text"><![CDATA[新需求～捕获Crash，虽然我每次提交代码之后都会说没BUG，测试吧。。。处女座，不能说没有，很少吧。 iTunes Connect的App分析中有，但是需要用户来设置，所以呢，没啥大用！！！ 很多第三方也可以做，比如友盟移动统计，Mob移动统计，百度移动统计等等。 如果你想自己实现呢？ 我给你俩工具，具体如何来做。。。那就看你学不学习了 DSYMTools分析工具,和邮件发送SKPSMTPMessage。 兄die，加油了。 Plcrashreporter听说这个很多大公司在用。了解下。。。]]></content>
      <tags>
        <tag>-iOS进阶</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo图片放置七牛云]]></title>
    <url>%2F2017%2F03%2F06%2Fhexo%E5%9B%BE%E7%89%87%E6%94%BE%E7%BD%AE%E4%B8%83%E7%89%9B%E4%BA%91%2F</url>
    <content type="text"><![CDATA[其实这是一个测试我配置完的博文，七牛放置图片很简单，百度一下就很多了。]]></content>
      <tags>
        <tag>-hexo记录</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[组件化]]></title>
    <url>%2F2017%2F03%2F03%2FiOS%E7%BB%84%E4%BB%B6%E5%8C%96%2F</url>
    <content type="text"><![CDATA[封装、封装再封装。如果你是单人开发，这么高耦合的代码会加速你的开发。但是，有时候业务逻辑有所改变，你会把项目改的很乱 Url-Block、Protocol-Class(Url-Controller)、Target-Action 思路都是走一个路由（中间件）来完成页面之间的传递信息。 网上的已经满天的文章了，具体内容我就不多说了。 我说一下一个项目是否该用组件化，怎么选择。 如果你是单人开发，公司的项目设计的业务不是特别多，你可以不考虑组件化，毕竟单人开发的时候有很多地方个人感觉完全没必要，只要不写很多高度耦合的代码出来一个MVVM可以应对项目。 如果不是单人开发，项目中设计的业务也比较广泛，还有公司可以会有多个业务，很多内容的功能都是类似的，可以考虑用组建来做。毕竟很多基础组建写好之后，可以在很多项目中重用。 至于选择，其实每个都有自己的优劣，不要被选择困惑。我个人比较喜欢Target-Action多一点。]]></content>
      <tags>
        <tag>-iOS进阶</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[无痕埋点]]></title>
    <url>%2F2017%2F02%2F03%2FiOS%E6%97%A0%E7%97%95%E5%9F%8B%E7%82%B9%2F</url>
    <content type="text"><![CDATA[以前都是手动来埋，有时候会忘记，研究了下无痕埋点，省掉了很多东西 Google了很多文章，发现都是面向切面的AOP思想来做的，总结起来就是偷梁换柱的Runtime黑魔法。 先来一大推的分类。来来来，统一替换埋点的方法。部分点击的分类要考虑深一点，比如UIButton使用UIControl会比较好，UIControl还包含了其他的一些控件。 那我怎么知道是哪个页面？ 来个plist文件对应表～ (NSString )pageEventID:(BOOL)enterPage{ NSDictionary configDict = [self dictionaryFromUserStatisticsConfigPlist]; NSString *selfClassName = NSStringFromClass([self class]); return configDict[selfClassName][@”PageEventIDs”][enterPage ? @”Enter” : @”Leave”];} (NSDictionary )dictionaryFromUserStatisticsConfigPlist{ NSString filePath = [[NSBundle mainBundle] pathForResource:@”Config” ofType:@”plist”]; NSDictionary *dic = [NSDictionary dictionaryWithContentsOfFile:filePath]; return dic;} 可能是记录blog，所以写的比较粗糙。 还有埋点的时候要善于使用XCTAssert。]]></content>
      <tags>
        <tag>-iOS进阶</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WebRTC]]></title>
    <url>%2F2017%2F01%2F05%2FWebRTC%2F</url>
    <content type="text"><![CDATA[WebRTC内容，简单集成。 搞个环境吧。。。 http://www.cnblogs.com/fulianga/p/5868823.html下载编译如果你要试试功能，去gitHub上随便找一个版本就行了。 一个头文件的文件夹，加一个.a文件。 导入系统依赖库CoreMedia.frameworkAVFoundation.frameworkAudioToolbox.frameworkGLKit.frameworkOpenGLES.frameworkVideoToolbox.frameworklibicucore.tbdlibstdc++.6.tbdlibc++.tbdlibresolv.tbdlibxml2.tbdOK环境完事了。 WebRTC主要实现了三个API，分别是:MediaStream：通过MediaStream的API能够通过设备的摄像头及话筒获得视频、音频的同步流。RTCPeerConnection：RTCPeerConnection是WebRTC用于构建点对点之间稳定、高效的流传输的组件。RTCDataChannel：RTCDataChannel使得浏览器之间（点对点）建立一个高吞吐量、低延时的信道，用于传输任意数据。其中RTCPeerConnection是我们WebRTC的核心组件。 1234567891011121314151617181920212223242526272829@protocol WebRTCHelperDelegate;@interface WebRTCHelper : NSObject&lt;SRWebSocketDelegate&gt;+ (instancetype)sharedInstance;@property (nonatomic, weak)id&lt;WebRTCHelperDelegate&gt; delegate;/*** 与服务器建立连接** @param server 服务器地址* @param room 房间号*/- (void)connectServer:(NSString *)server port:(NSString *)port room:(NSString *)room;/*** 退出房间*/- (void)exitRoom;@end@protocol WebRTCHelperDelegate &lt;NSObject&gt;@optional- (void)webRTCHelper:(WebRTCHelper *)webRTChelper setLocalStream:(RTCMediaStream *)stream userId:(NSString *)userId;- (void)webRTCHelper:(WebRTCHelper *)webRTChelper addRemoteStream:(RTCMediaStream *)stream userId:(NSString *)userId;- (void)webRTCHelper:(WebRTCHelper *)webRTChelper closeWithUserId:(NSString *)userId;@end 把所有的头文件都看一圈。。。em。。。反正没人看，我就是自己记录一下而已。 具体实现过程的文章。 iOS下音视频通信-基于WebRTC还有一些即时通讯的文章，统一在这记录一下。。。iOS即时通讯，从入门到“放弃”？iOS即时通讯进阶 - CocoaAsyncSocket源码解析(Connect篇)iOS即时通讯进阶 - CocoaAsyncSocket源码解析(Connect篇终)iOS即时通讯进阶 - CocoaAsyncSocket源码解析(Read篇)iOS即时通讯进阶 - CocoaAsyncSocket源码解析(Read篇终) 上面的作者很用心，写了很多，多读读，其实简单实现还是很容易的。但是！！！你要知道你的Demo只面对了你自己，当你面对9亿网民的时候，有可能分分钟就被干趴了，还是要好好研究才能上项目的。]]></content>
      <tags>
        <tag>-iOS进阶</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[视频直播]]></title>
    <url>%2F2017%2F01%2F03%2FiOS%E8%A7%86%E9%A2%91%E7%9B%B4%E6%92%AD%2F</url>
    <content type="text"><![CDATA[现在第三方集成视频直播的有很多了，想完成一个其实一顿SDK很无脑的就能搞出一个APP。 鉴于对程序的热爱（必不得已）仔细的研究了整个视频直播的过程，具体实现没有做，很多大咖写的非常好了，写这篇播客的目的就是, 想记录一下当时的思路。 主播端：1）需要做的音视频采集2）视频处理、美颜滤镜之类的（毕竟主播要美美哒）3）视频编码。4）推流到服务器（RTMP,HLS,FLV） 用户端：1）拉流。2）解码。3）观看。 用什么来做？em。。。B站的ijkPlayer听过没。如果没有，那ffmpeg了解下。 在说一下其他的东西，如果真的想在图像视频方面深挖，学学OpenGL（ES）其实不错的。 WebRTC内容，之后在写吧。。。。]]></content>
      <tags>
        <tag>-iOS进阶</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[远程Git仓库]]></title>
    <url>%2F2016%2F08%2F10%2F%E8%BF%9C%E7%A8%8BGit%E4%BB%93%E5%BA%93%2F</url>
    <content type="text"><![CDATA[脑子不好用了，总是忘记点啥，还是备注下吧 开始～～～～～～ 远程私有仓库（分支仓库） pod repo 看看有没有自己的！ pod repo add 私有库名字 你的私有库地址 pod lib create XXX 然后一顿选择。 cd到目录下 添加git远程私有库关联 git remote查看，应该是没有的，如果你不相信就自己看下咯。 git remote add origin XXX 修改podspec文件s.summary 、s.homepage、s.source、s.source_files等等，自行百度。分支内容来了！！！！s.source_files注释掉s.subspec ‘XXX’ do |X| X.source_files = ‘路径’ X.dependency = ‘其他库’end 提交去远程仓库$ git add . git add -A 提交所有变化 git add -u 提交被修改(modified)和被删除(deleted)文件，不包括新文件(new) git add . 提交新文件(new)和被修改(modified)文件，不包括被删除(deleted)文件 $ git status 看看是不是都变绿了 $ git commit -m “首次提交内容，等待上传其他基础组件” 上传代码$ git push origin master 打标签，并且把标签提交到远程私地址$ git tag$ git tag -a ‘0.1.0’ -m “标签显示内容”上传标签 $ git push –tags 验证spec并提交到本地私有索引库验证本地 $ pod lib lint验证远程 $ pod spec lint都通过后提交本地$ pod repo push XXX XXX.podspec 使用的时候 soure’adress’ pod ‘spec’pod ‘spec/xxx’pod ‘spec’, :subspecs =&gt; [‘xxx’, ‘xxx’] 验证spec的时候如果你引用了私有的库 在验证后面加上–sources=地址,master 更多内容查看help]]></content>
      <tags>
        <tag>-环境搭建</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[本地Git仓库]]></title>
    <url>%2F2016%2F08%2F09%2F%E6%9C%AC%E5%9C%B0Git%E4%BB%93%E5%BA%93%2F</url>
    <content type="text"><![CDATA[本地Git仓库搭建，小小渣渣给自己Blog留痕，大咖直接忽视，如果错误请指出。谢啦！ 开始～～～～～～ mkdir MyGit 创建一个目录，cd到当前目录—&gt;MyGit，$ git init Cookies-MacBook-Pro:MyGit Cookie$ git initInitialized empty Git repository in /Users/Cookie/MyGit/.git/ ？？？怎么什么都没有？？？ 创建了一个隐藏的文件夹.git，我想看看文件夹里都有什么，嗯嗯，简单。输入下面的指令 $ defaults write com.apple.finder AppleShowAllFiles -bool true //显示隐藏文件（false）$ KillAll Finder 配置个人信息：1、一次性的配置， 只会配置到被管理文件的.git文件夹 $ git config user.name Cookie$ git config user.email 373733319@qq.com 2、XX性的配置， 只会配置到被管理文件的.git文件夹 $ git config –global user.name Cookie$ git config –global user.email 373733319@qq.com $ git config –list查看配置信息 go on 创建一个文件夹，名字叫CustomNavgationBar，然后把你想制作成pod库的文件夹复制进去。如图： 然后按顺序执行下面操作： cd到上层的CustomNavgationBar $ git add . &amp;&amp; git commit -m “commit my test code”（我也不知道干什么用的） git add -A 提交所有变化 git add -u 提交被修改(modified)和被删除(deleted)文件，不包括新文件(new) git add . 提交新文件(new)和被修改(modified)文件，不包括被删除(deleted)文件 git commit - “提交的内容是啥” $ pod spec create CustomNavgationBar 然后你多了一个CustomNavgationBar.podspec文件，右键打开。具体工具看你电脑里有啥了。 修改如下位置： s.source = { :git =&gt; “/Users/Cookie/MyGit/CustomNavgationBar”, :tag =&gt; “#{s.version}” }s.description = &lt;&lt;-DESC TODO: Add long description of the pod here. DESCs.license = “MIT”s.source_files = “CustomNavgationBar”, “CustomNavgationBar/*/.{h,m}”s.exclude_files = “CustomNavgationBar/Exclude” 然后回到pods文件添加本地库：pod ‘CustomNavgationBar’, :path =&gt; ‘/Users/XXX/MyGit/CustomNavgationBar’ 添加完成之后最后的步骤——————pod install，啊嘿！ 我是用的XCode，然后在Pods下面有个叫Development Pods的文件夹，下面就是你刚刚Pods的文件喔！！！ 就是感觉哪里不对，然后发现了新的东西！！！ pod lib create XXX 然后一顿选择。修改XXX的.podspec文件s.source = { :git =&gt; ‘/Users/Cookie/Desktop/NewProject/LJXMediator’, :tag =&gt; s.version.to_s }s.source_files = ‘XXX/Classes//*’s.public_header_files = ‘XXX/Classes//*.h’依赖库s.dependency ‘AFNetworking’, ‘~&gt; 2.3’ cd 到XXX的Example目录下，pod install 在其他的Podfile文件下pod ‘XXX’, :path =&gt; ‘/Users/Cookie/Desktop/NewProject/XXX’ pod install 远程仓库 pod trunk register注册！！！！ github上创建项目，然后本地新建文件夹，在文件夹中新建一个Classes文件夹，需要上传的文件放到此文件夹中。cd到Classes上一级目录，git init git add . git commit -m “第一版上传” git remote add origin XXX git push -u origin master pod spec create XXX 修改地址 git tag ‘xxx’ git push –tags pod trunk push XXXX]]></content>
      <tags>
        <tag>-环境搭建</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[FMDB使用优化]]></title>
    <url>%2F2016%2F07%2F06%2FFMDB%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[本地数据库存储，CoreData研究几天，发现一个大问题，虽然可视化，但是它竟然没有自增主键，这我就受不了了，大佬说CoreData很难的，遂卒。反正我就是要弄个小小的本地数据库，改道来了sqlite+FMDB。遂写了一篇文章，来记录过程。 在二次封装FMDB的时候我就蛋疼了一下下，看了下源码FMDatabase和FMDatabaseQueue。这特么是啥？怎么还是两个。通过XX一下，哦哦，soga，一个是可以多线程，一个不可以嘛。 但是！！！ 嗯，说一下吧，如果你没有看过库表，你要开始使用的时候，你要跳出一个圈，那就是库是库，表是表，他们俩不是一个东西！！！ 等等。。。]]></content>
      <tags>
        <tag>-OC进阶</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[真机测试如何拿到本地资源]]></title>
    <url>%2F2016%2F06%2F06%2F%E7%9C%9F%E6%9C%BA%E6%B5%8B%E8%AF%95%E5%A6%82%E4%BD%95%E6%8B%BF%E5%88%B0%E6%9C%AC%E5%9C%B0%E8%B5%84%E6%BA%90%2F</url>
    <content type="text"><![CDATA[Xcode运行真机或虚拟机测试的时候，有一些需要看看本地缓存或者其他的资源，如何查看呢？ 来来来，步骤如下： WindowDevices and Simulators上面选择类型我选择真机DevicesINSTALLED APPS下面是不是有一大堆APP，嗯选中你的要查看的APP点击下面设置形状的小图标会有3个选择Download Container，保存到好找的地方，我保存到桌面。你会得到一个XXX.xcappd文件，右键-显示包裹内容。你看到一个AppData文件夹。点进去看看～～～ GG 备注：有时候我会突然忘记一点东西，给自己备用，也给一些新人指引。]]></content>
      <tags>
        <tag>-OC杂记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SDWebImage缓存图片更新]]></title>
    <url>%2F2016%2F05%2F05%2FSDWebImage%E7%BC%93%E5%AD%98%E5%9B%BE%E7%89%87%E6%9B%B4%E6%96%B0%2F</url>
    <content type="text"><![CDATA[我的朋友最近问我SDWebImage缓存的问题，就写了一篇小Blog，记录一下。 首先，打开浏览器，Google一下SDWebImage更新缓存图片。 嗯嗯，你得到了一个回答，内容大致如下： 12345dispatch_async(dispatch_get_global_queue(0, 0), ^&#123; dispatch_async(dispatch_get_main_queue(), ^&#123; [self.iconView sd_setImageWithURL:[NSURL URLWithString:URL(myModel.icon)] placeholderImage:nil options:SDWebImageRefreshCached]; &#125;);&#125;); SDWebImageRefreshCached看字面意思就是更新缓存嘛，SD的官方也是说用这个方法的啊，看起来很简单嘛，然而事情没有你想的那么简单，你会发现问题如下: 1、图片没有更新。2、图片没有了。3、XXXXXX等问题。 仔细看看源码的注解 1234567if (image &amp;&amp; options &amp; SDWebImageRefreshCached) &#123; dispatch_main_sync_safe(^&#123; // If image was found in the cache but SDWebImageRefreshCached is provided, notify about the cached image // AND try to re-download it in order to let a chance to NSURLCache to refresh it from server. completedBlock(image, nil, cacheType, YES, url); &#125;);&#125; 说是如果缓存中有图片先用，然后图片有更新让NSURLCache从服务器下载新的，来后来我仔细Google一下，服务器需要支持Cache-Control，SDWebImageRefreshCached这个属性才会生效，打开终端，输入 curl 图片url –head 看看有没有Cache-Control:max-age=xxx；如果不存在说明服务不支持，这个xxx就是图片缓存有效时长，设置的时间短呢，很次请求都要去刷新图片，是不是感觉SD的图片缓存的功能似乎没有用了呢。时间长了改变图片不会刷新，很纠结的问题。 想来想去解决方案有几种方法 1、用SDWebImageCacheMemoryOnly属性，每次大退之后呢，缓存清除了。重新启动后所有图片要重新加载。或者在启动配置分类里写[[SDImageCache sharedImageCache] clearDisk]这个方法是一样的。 2、服务器更换图片加后缀，比如最开始的图片叫1.png，更新图片后改名为1_1.png这样图片的Url改变了，就会重新请求。 3、也是目前比较高逼格的。还是使用SDWebImageRefreshCached属性，需要服务端支持一下下。curl之后拿到如下的结果，发现有ETag和Last-Modified。 HTTP/1.1 200 OK Server: nginx Date: Mon, 05 Mar 2018 10:14:57 GMT Content-Type: image/png;charset=UTF-8 Content-Length: 4469 Connection: keep-alive Access-Control-Allow-Origin: * Accept-Ranges: bytes ETag: W/“4469-1517398918000” Last-Modified: Wed, 31 Jan 2018 11:41:58 GMT 网上漫天的贴了一段相同的代码 123456789101112131415161718192021222324252627282930313233343536373839SDWebImageDownloader *imgDownloader = SDWebImageManager.sharedManager.imageDownloader;imgDownloader.headersFilter = ^NSDictionary *(NSURL *url, NSDictionary *headers) &#123; NSFileManager *fm = [[NSFileManager alloc] init]; NSString *imgKey = [SDWebImageManager.sharedManager cacheKeyForURL:url]; NSString *imgPath = [SDWebImageManager.sharedManager.imageCache defaultCachePathForKey:imgKey]; NSDictionary *fileAttr = [fm attributesOfItemAtPath:imgPath error:nil]; NSMutableDictionary *mutableHeaders = [headers mutableCopy]; NSDate *lastModifiedDate = nil; if (fileAttr.count &gt; 0) &#123; if (fileAttr.count &gt; 0) &#123; lastModifiedDate = (NSDate *)fileAttr[NSFileModificationDate]; &#125; &#125; NSDateFormatter *formatter = [[NSDateFormatter alloc] init]; formatter.timeZone = [NSTimeZone timeZoneWithAbbreviation:@"GMT"]; formatter.locale = [[NSLocale alloc] initWithLocaleIdentifier:@"en_US"]; formatter.dateFormat = @"EEE, dd MMM yyyy HH:mm:ss z"; NSString *lastModifiedStr = [formatter stringFromDate:lastModifiedDate]; lastModifiedStr = lastModifiedStr.length &gt; 0 ? lastModifiedStr : @""; [mutableHeaders setValue:lastModifiedStr forKey:@"If-Modified-Since"]; return mutableHeaders;&#125;; 嗯，加在启动的配置项里。然后你发现你的图片记载并不好使。他们说是需要服务端支持，如果图片有更新返回code200，返回新的ETag和Last-Modified，如果没有更新呢，返回304。SD上面有一段对304的判断： 1234567891011121314//'304 Not Modified' is an exceptional oneif (![response respondsToSelector:@selector(statusCode)] || ([((NSHTTPURLResponse *)response) statusCode] &lt; 400 &amp;&amp; [((NSHTTPURLResponse *)response) statusCode] != 304)) &#123; NSInteger expected = response.expectedContentLength &gt; 0 ? (NSInteger)response.expectedContentLength : 0; self.expectedSize = expected; if (self.progressBlock) &#123; self.progressBlock(0, expected); &#125; self.imageData = [[NSMutableData alloc] initWithCapacity:expected]; self.response = response; dispatch_async(dispatch_get_main_queue(), ^&#123; [[NSNotificationCenter defaultCenter] postNotificationName:SDWebImageDownloadReceiveResponseNotification object:self]; &#125;);&#125; 如果是304，就说明没有新的图片。。。我们服务器估计没有304的判断，所以我也没有做验证，毕竟我是个新手，验证还是要靠你们，晚上8点了，就写这么多了，有问题的话大佬们指出下，我再去重新看一遍。]]></content>
      <tags>
        <tag>-OC进阶</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo新建文章操作]]></title>
    <url>%2F2016%2F04%2F28%2Fhexo%E6%96%B0%E5%BB%BA%E6%96%87%E7%AB%A0%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[个人博客不是经常会用，所以总是忘记Hexo的一些命令，最近重新捡起来，把发布新文章的操作从新纪录一下。 cd 到放置文章的_post目录下创建一篇新文章 hexo new post “xxx”执行发布命令 hexo clean 、 hexo d -g 上传完成、刷新页面，嗯嗯是不是发现404了。 CNAME 文件没了，域名指向。 网上都说创建CNMAE文件不要后缀，怎么创建呢？想了N种方法怕出错，直接终端vim就好了，把文件放到Hexo-blog-source目录下，这样下次就不用重新来生成了。 以下为本人脑残纪录，跟上述内容无关 阅读统计：LeanCloud 微博登录的。评论：来必力 手机号还是邮箱的忘掉了。图片：七牛云上配置 应该诗手记。]]></content>
      <tags>
        <tag>-hexo记录</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++创建新类如何关联到main.cpp上]]></title>
    <url>%2F2016%2F04%2F15%2FC-%E5%88%9B%E5%BB%BA%E6%96%B0%E7%B1%BB%E5%A6%82%E4%BD%95%E5%85%B3%E8%81%94%E5%88%B0main-cpp%E4%B8%8A%2F</url>
    <content type="text"><![CDATA[对于无C++基础的人来说，新建一个.h和.cpp如何与main.cpp关联是一脸懵逼的状态。 本人用mac的Xcode来学习C++的，所以创建的.hpp与.h是一个东西首先创建一个新类LJX_One.hpp和LJX_One.cpp LJX_One.hpp代码 12345678910111213141516#ifndef LJX_One_hpp#define LJX_One_hpp#include &lt;stdio.h&gt;class LJX &#123; public: LJX()&#123;&#125;; ~LJX()&#123;&#125;; public: int sort(); void compact(); void write();&#125;;#endif /* LJX_One_hpp */ LJX_One.cpp代码 123456789101112131415161718192021222324252627282930#include &lt;iostream&gt;#include "LJX_One.hpp"using namespace std;int LJX::sort()&#123; return 1;&#125;void LJX::compact()&#123; int ljx_count = 1024; int * ljx_isa = &amp;ljx_count; *ljx_isa = *ljx_isa + 1; cout &lt;&lt; ljx_count; cout &lt;&lt;"\n";&#125;void LJX::write()&#123; int *pi = new int( 0 ); int *pia = new int[ 10 ]; while ( *pi &lt; 10 ) &#123; pia[ *pi ] = *pi; cout &lt;&lt; pia[ *pi ] &lt;&lt; "\n"; *pi = *pi + 1; &#125; delete pi; delete [] pia;&#125; main.cpp中调用 12345678910111213141516171819#include &lt;iostream&gt;#include &lt;string&gt;#include "LJX_One.hpp"using namespace std;int main(int argc, const char * argv[]) &#123;LJX first;int count = first.sort();if (count == 0) &#123; first.compact();&#125; else &#123; first.write();&#125;return 0;&#125;]]></content>
      <tags>
        <tag>-C++初探</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[开始写博客]]></title>
    <url>%2F2016%2F03%2F05%2F%E5%BC%80%E5%A7%8B%E5%86%99%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[Blog。 个人感觉，现在的Github上em。。。所以现在很少上Github上down代码来看，都是在Stackoverflow瞎逛。 以前很多东西都是放在脑子里的，出现问题会微微的有一点印象，随便Google下，就可以了。最近工作不是那么稳定，有点想去大佬的地方呆呆，学习一点东西的想法。所以重拾个人博客，至于Github，自己搭建过很多的框架，每次都不满意，最近又开始新的旅程。等我在自己的水平上，搭建完自己满意的东西，会把平时用的都搞上去，然后在上传。亲们，我只是一个小渣渣，不好的地方请不要打我，先行谢过！！！]]></content>
      <tags>
        <tag>-杂记</tag>
      </tags>
  </entry>
</search>
