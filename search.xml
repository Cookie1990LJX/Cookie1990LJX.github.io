<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[离屏渲染问题]]></title>
    <url>%2F2017%2F04%2F02%2FGPU%E7%A6%BB%E5%B1%8F%E6%B8%B2%E6%9F%93%2F</url>
    <content type="text"><![CDATA[这个是我没事的时候在Stackoverflow瞎溜达时候看的 什么是离屏渲染？ GPU了解下？ OpenGL的中，GPU屏幕渲染有两种方式。屏幕渲染（当前屏幕渲染）指的是GPU的渲染操作是在当前用于显示的屏幕缓冲区进行。离屏渲染（离屏渲染）指的是在GPU在当前屏幕缓冲区以外开辟一个缓冲区进行渲染操作。当发生离屏的时候，可能导致FPS下降，说白了，卡顿。人眼的辨识是30+ 什么时候会发生离屏渲染 光栅化、遮罩、阴影、抗锯齿、不透明、复杂形状设置圆角等等，所以新建的空间如果能透明就透明。 怎么检测呢？Instruments的Core Animation工具中有几个和离屏渲染相关的检查选项：Color Offscreen-Rendered Yellow开启后会把那些需要离屏渲染的图层高亮成黄色，这就意味着黄色图层可能存在性能问题。Color Hits Green and Misses Red 更新下，改版了新的Xcode（Debug）-（View Debugging）-（Rendering）-（Color Offscreen-Rendered Yellow）]]></content>
      <tags>
        <tag>-iOS进阶</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[组件化]]></title>
    <url>%2F2017%2F03%2F09%2FCrash%E6%94%B6%E9%9B%86%2F</url>
    <content type="text"><![CDATA[新需求～捕获Crash，虽然我每次提交代码之后都会说没BUG，测试吧。。。处女座，不能说没有，很少吧。 iTunes Connect的App分析中有，但是需要用户来设置，所以呢，没啥大用！！！ 很多第三方也可以做，比如友盟移动统计，Mob移动统计，百度移动统计等等。 如果你想自己实现呢？ 我给你俩工具，具体如何来做。。。那就看你学不学习了 DSYMTools分析工具,和邮件发送SKPSMTPMessage。 兄die，加油了。]]></content>
      <tags>
        <tag>-iOS进阶</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo图片放置七牛云]]></title>
    <url>%2F2017%2F03%2F06%2Fhexo%E5%9B%BE%E7%89%87%E6%94%BE%E7%BD%AE%E4%B8%83%E7%89%9B%E4%BA%91%2F</url>
    <content type="text"><![CDATA[其实这是一个测试我配置完的博文，七牛放置图片很简单，百度一下就很多了。]]></content>
      <tags>
        <tag>-hexo记录</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[组件化]]></title>
    <url>%2F2017%2F03%2F03%2FiOS%E7%BB%84%E4%BB%B6%E5%8C%96%2F</url>
    <content type="text"><![CDATA[封装、封装再封装。如果你是单人开发，这么高耦合的代码会加速你的开发。但是，有时候业务逻辑有所改变，你会把项目改的很乱 Url-Block、Protocol-Class(Url-Controller)、Target-Action 思路都是走一个路由（中间件）来完成页面之间的传递信息。 网上的已经满天的文章了，具体内容我就不多说了。 我说一下一个项目是否该用组件化，怎么选择。 如果你是单人开发，公司的项目设计的业务不是特别多，你可以不考虑组件化，毕竟单人开发的时候有很多地方个人感觉完全没必要，只要不写很多高度耦合的代码出来一个MVVM可以应对项目。 如果不是单人开发，项目中设计的业务也比较广泛，还有公司可以会有多个业务，很多内容的功能都是类似的，可以考虑用组建来做。毕竟很多基础组建写好之后，可以在很多项目中重用。 至于选择，其实每个都有自己的优劣，不要被选择困惑。我个人比较喜欢Target-Action多一点。]]></content>
      <tags>
        <tag>-iOS进阶</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[无痕埋点]]></title>
    <url>%2F2017%2F02%2F03%2FiOS%E6%97%A0%E7%97%95%E5%9F%8B%E7%82%B9%2F</url>
    <content type="text"><![CDATA[以前都是手动来埋，有时候会忘记，研究了下无痕埋点，省掉了很多东西 Google了很多文章，发现都是面向切面的AOP思想来做的，总结起来就是偷梁换柱的Runtime黑魔法。 先来一大推的分类。来来来，统一替换埋点的方法。部分点击的分类要考虑深一点，比如UIButton使用UIControl会比较好，UIControl还包含了其他的一些控件。 那我怎么知道是哪个页面？ 来个plist文件对应表～ (NSString )pageEventID:(BOOL)enterPage{ NSDictionary configDict = [self dictionaryFromUserStatisticsConfigPlist]; NSString *selfClassName = NSStringFromClass([self class]); return configDict[selfClassName][@”PageEventIDs”][enterPage ? @”Enter” : @”Leave”];} (NSDictionary )dictionaryFromUserStatisticsConfigPlist{ NSString filePath = [[NSBundle mainBundle] pathForResource:@”Config” ofType:@”plist”]; NSDictionary *dic = [NSDictionary dictionaryWithContentsOfFile:filePath]; return dic;} 可能是记录blog，所以写的比较粗糙。 还有埋点的时候要善于使用XCTAssert。]]></content>
      <tags>
        <tag>-iOS进阶</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[视频直播]]></title>
    <url>%2F2017%2F01%2F03%2FiOS%E8%A7%86%E9%A2%91%E7%9B%B4%E6%92%AD%2F</url>
    <content type="text"><![CDATA[现在第三方集成视频直播的有很多了，想完成一个其实一顿SDK很无脑的就能搞出一个APP。 鉴于对程序的热爱（必不得已）仔细的研究了整个视频直播的过程，具体实现没有做，很多大咖写的非常好了，写这篇播客的目的就是, 想记录一下当时的思路。 主播端：1）需要做的音视频采集2）视频处理、美颜滤镜之类的（毕竟主播要美美哒）3）视频编码。4）推流到服务器（RTMP,HLS,FLV） 用户端：1）拉流。2）解码。3）观看。 用什么来做？em。。。B站的ijkPlayer听过没。如果没有，那ffmpeg了解下。 在说一下其他的东西，如果真的想在图像视频方面深挖，学学OpenGL（ES）其实不错的。]]></content>
      <tags>
        <tag>-iOS进阶</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[远程Git仓库]]></title>
    <url>%2F2016%2F08%2F10%2F%E8%BF%9C%E7%A8%8BGit%E4%BB%93%E5%BA%93%2F</url>
    <content type="text"><![CDATA[脑子不好用了，总是忘记点啥，还是备注下吧 开始～～～～～～ 远程私有仓库（分支仓库） pod repo 看看有没有自己的！ pod repo add 私有库名字 你的私有库地址 pod lib create XXX 然后一顿选择。 cd到目录下 添加git远程私有库关联 git remote查看，应该是没有的，如果你不相信就自己看下咯。 git remote add origin XXX 修改podspec文件s.summary 、s.homepage、s.source、s.source_files等等，自行百度。分支内容来了！！！！s.source_files注释掉s.subspec ‘XXX’ do |X| X.source_files = ‘路径’ X.dependency = ‘其他库’end 提交去远程仓库$ git add . git add -A 提交所有变化 git add -u 提交被修改(modified)和被删除(deleted)文件，不包括新文件(new) git add . 提交新文件(new)和被修改(modified)文件，不包括被删除(deleted)文件 $ git status 看看是不是都变绿了 $ git commit -m “首次提交内容，等待上传其他基础组件” 上传代码$ git push origin master 打标签，并且把标签提交到远程私地址$ git tag$ git tag -a ‘0.1.0’ -m “标签显示内容”上传标签 $ git push –tags 验证spec并提交到本地私有索引库验证本地 $ pod lib lint验证远程 $ pod spec lint都通过后提交本地$ pod repo push XXX XXX.podspec 使用的时候 soure’adress’ pod ‘spec’pod ‘spec/xxx’pod ‘spec’, :subspecs =&gt; [‘xxx’, ‘xxx’] 验证spec的时候如果你引用了私有的库 在验证后面加上–sources=地址,master 更多内容查看help]]></content>
      <tags>
        <tag>-环境搭建</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[本地Git仓库]]></title>
    <url>%2F2016%2F08%2F09%2F%E6%9C%AC%E5%9C%B0Git%E4%BB%93%E5%BA%93%2F</url>
    <content type="text"><![CDATA[本地Git仓库搭建，小小渣渣给自己Blog留痕，大咖直接忽视，如果错误请指出。谢啦！ 开始～～～～～～ mkdir MyGit 创建一个目录，cd到当前目录—&gt;MyGit，$ git init Cookies-MacBook-Pro:MyGit Cookie$ git initInitialized empty Git repository in /Users/Cookie/MyGit/.git/ ？？？怎么什么都没有？？？ 创建了一个隐藏的文件夹.git，我想看看文件夹里都有什么，嗯嗯，简单。输入下面的指令 $ defaults write com.apple.finder AppleShowAllFiles -bool true //显示隐藏文件（false）$ KillAll Finder 配置个人信息：1、一次性的配置， 只会配置到被管理文件的.git文件夹 $ git config user.name Cookie$ git config user.email 373733319@qq.com 2、XX性的配置， 只会配置到被管理文件的.git文件夹 $ git config –global user.name Cookie$ git config –global user.email 373733319@qq.com $ git config –list查看配置信息 go on 创建一个文件夹，名字叫CustomNavgationBar，然后把你想制作成pod库的文件夹复制进去。如图： 然后按顺序执行下面操作： cd到上层的CustomNavgationBar $ git add . &amp;&amp; git commit -m “commit my test code”（我也不知道干什么用的） git add -A 提交所有变化 git add -u 提交被修改(modified)和被删除(deleted)文件，不包括新文件(new) git add . 提交新文件(new)和被修改(modified)文件，不包括被删除(deleted)文件 git commit - “提交的内容是啥” $ pod spec create CustomNavgationBar 然后你多了一个CustomNavgationBar.podspec文件，右键打开。具体工具看你电脑里有啥了。 修改如下位置： s.source = { :git =&gt; “/Users/Cookie/MyGit/CustomNavgationBar”, :tag =&gt; “#{s.version}” }s.description = &lt;&lt;-DESC TODO: Add long description of the pod here. DESCs.license = “MIT”s.source_files = “CustomNavgationBar”, “CustomNavgationBar/*/.{h,m}”s.exclude_files = “CustomNavgationBar/Exclude” 然后回到pods文件添加本地库：pod ‘CustomNavgationBar’, :path =&gt; ‘/Users/XXX/MyGit/CustomNavgationBar’ 添加完成之后最后的步骤——————pod install，啊嘿！ 我是用的XCode，然后在Pods下面有个叫Development Pods的文件夹，下面就是你刚刚Pods的文件喔！！！ 就是感觉哪里不对，然后发现了新的东西！！！ pod lib create XXX 然后一顿选择。修改XXX的.podspec文件s.source = { :git =&gt; ‘/Users/Cookie/Desktop/NewProject/LJXMediator’, :tag =&gt; s.version.to_s }s.source_files = ‘XXX/Classes//*’s.public_header_files = ‘XXX/Classes//*.h’依赖库s.dependency ‘AFNetworking’, ‘~&gt; 2.3’ cd 到XXX的Example目录下，pod install 在其他的Podfile文件下pod ‘XXX’, :path =&gt; ‘/Users/Cookie/Desktop/NewProject/XXX’ pod install 远程仓库 pod trunk register注册！！！！ github上创建项目，然后本地新建文件夹，在文件夹中新建一个Classes文件夹，需要上传的文件放到此文件夹中。cd到Classes上一级目录，git init git add . git commit -m “第一版上传” git remote add origin XXX git push -u origin master pod spec create XXX 修改地址 git tag ‘xxx’ git push –tags pod trunk push XXXX]]></content>
      <tags>
        <tag>-环境搭建</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[FMDB使用优化]]></title>
    <url>%2F2016%2F07%2F06%2FFMDB%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[本地数据库存储，CoreData研究几天，发现一个大问题，虽然可视化，但是它竟然没有自增主键，这我就受不了了，大佬说CoreData很难的，遂卒。反正我就是要弄个小小的本地数据库，改道来了sqlite+FMDB。遂写了一篇文章，来记录过程。 在二次封装FMDB的时候我就蛋疼了一下下，看了下源码FMDatabase和FMDatabaseQueue。这特么是啥？怎么还是两个。通过XX一下，哦哦，soga，一个是可以多线程，一个不可以嘛。 但是！！！ 嗯，说一下吧，如果你没有看过库表，你要开始使用的时候，你要跳出一个圈，那就是库是库，表是表，他们俩不是一个东西！！！ 等等。。。]]></content>
      <tags>
        <tag>-OC进阶</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[真机测试如何拿到本地资源]]></title>
    <url>%2F2016%2F06%2F06%2F%E7%9C%9F%E6%9C%BA%E6%B5%8B%E8%AF%95%E5%A6%82%E4%BD%95%E6%8B%BF%E5%88%B0%E6%9C%AC%E5%9C%B0%E8%B5%84%E6%BA%90%2F</url>
    <content type="text"><![CDATA[Xcode运行真机或虚拟机测试的时候，有一些需要看看本地缓存或者其他的资源，如何查看呢？ 来来来，步骤如下： WindowDevices and Simulators上面选择类型我选择真机DevicesINSTALLED APPS下面是不是有一大堆APP，嗯选中你的要查看的APP点击下面设置形状的小图标会有3个选择Download Container，保存到好找的地方，我保存到桌面。你会得到一个XXX.xcappd文件，右键-显示包裹内容。你看到一个AppData文件夹。点进去看看～～～ GG 备注：有时候我会突然忘记一点东西，给自己备用，也给一些新人指引。]]></content>
      <tags>
        <tag>-OC杂记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SDWebImage缓存图片更新]]></title>
    <url>%2F2016%2F05%2F05%2FSDWebImage%E7%BC%93%E5%AD%98%E5%9B%BE%E7%89%87%E6%9B%B4%E6%96%B0%2F</url>
    <content type="text"><![CDATA[我的朋友最近问我SDWebImage缓存的问题，就写了一篇小Blog，记录一下。 首先，打开浏览器，Google一下SDWebImage更新缓存图片。 嗯嗯，你得到了一个回答，内容大致如下： 12345dispatch_async(dispatch_get_global_queue(0, 0), ^&#123; dispatch_async(dispatch_get_main_queue(), ^&#123; [self.iconView sd_setImageWithURL:[NSURL URLWithString:URL(myModel.icon)] placeholderImage:nil options:SDWebImageRefreshCached]; &#125;);&#125;); SDWebImageRefreshCached看字面意思就是更新缓存嘛，SD的官方也是说用这个方法的啊，看起来很简单嘛，然而事情没有你想的那么简单，你会发现问题如下: 1、图片没有更新。2、图片没有了。3、XXXXXX等问题。 仔细看看源码的注解 1234567if (image &amp;&amp; options &amp; SDWebImageRefreshCached) &#123; dispatch_main_sync_safe(^&#123; // If image was found in the cache but SDWebImageRefreshCached is provided, notify about the cached image // AND try to re-download it in order to let a chance to NSURLCache to refresh it from server. completedBlock(image, nil, cacheType, YES, url); &#125;);&#125; 说是如果缓存中有图片先用，然后图片有更新让NSURLCache从服务器下载新的，来后来我仔细Google一下，服务器需要支持Cache-Control，SDWebImageRefreshCached这个属性才会生效，打开终端，输入 curl 图片url –head 看看有没有Cache-Control:max-age=xxx；如果不存在说明服务不支持，这个xxx就是图片缓存有效时长，设置的时间短呢，很次请求都要去刷新图片，是不是感觉SD的图片缓存的功能似乎没有用了呢。时间长了改变图片不会刷新，很纠结的问题。 想来想去解决方案有几种方法 1、用SDWebImageCacheMemoryOnly属性，每次大退之后呢，缓存清除了。重新启动后所有图片要重新加载。或者在启动配置分类里写[[SDImageCache sharedImageCache] clearDisk]这个方法是一样的。 2、服务器更换图片加后缀，比如最开始的图片叫1.png，更新图片后改名为1_1.png这样图片的Url改变了，就会重新请求。 3、也是目前比较高逼格的。还是使用SDWebImageRefreshCached属性，需要服务端支持一下下。curl之后拿到如下的结果，发现有ETag和Last-Modified。 HTTP/1.1 200 OK Server: nginx Date: Mon, 05 Mar 2018 10:14:57 GMT Content-Type: image/png;charset=UTF-8 Content-Length: 4469 Connection: keep-alive Access-Control-Allow-Origin: * Accept-Ranges: bytes ETag: W/“4469-1517398918000” Last-Modified: Wed, 31 Jan 2018 11:41:58 GMT 网上漫天的贴了一段相同的代码 123456789101112131415161718192021222324252627282930313233343536373839SDWebImageDownloader *imgDownloader = SDWebImageManager.sharedManager.imageDownloader;imgDownloader.headersFilter = ^NSDictionary *(NSURL *url, NSDictionary *headers) &#123; NSFileManager *fm = [[NSFileManager alloc] init]; NSString *imgKey = [SDWebImageManager.sharedManager cacheKeyForURL:url]; NSString *imgPath = [SDWebImageManager.sharedManager.imageCache defaultCachePathForKey:imgKey]; NSDictionary *fileAttr = [fm attributesOfItemAtPath:imgPath error:nil]; NSMutableDictionary *mutableHeaders = [headers mutableCopy]; NSDate *lastModifiedDate = nil; if (fileAttr.count &gt; 0) &#123; if (fileAttr.count &gt; 0) &#123; lastModifiedDate = (NSDate *)fileAttr[NSFileModificationDate]; &#125; &#125; NSDateFormatter *formatter = [[NSDateFormatter alloc] init]; formatter.timeZone = [NSTimeZone timeZoneWithAbbreviation:@"GMT"]; formatter.locale = [[NSLocale alloc] initWithLocaleIdentifier:@"en_US"]; formatter.dateFormat = @"EEE, dd MMM yyyy HH:mm:ss z"; NSString *lastModifiedStr = [formatter stringFromDate:lastModifiedDate]; lastModifiedStr = lastModifiedStr.length &gt; 0 ? lastModifiedStr : @""; [mutableHeaders setValue:lastModifiedStr forKey:@"If-Modified-Since"]; return mutableHeaders;&#125;; 嗯，加在启动的配置项里。然后你发现你的图片记载并不好使。他们说是需要服务端支持，如果图片有更新返回code200，返回新的ETag和Last-Modified，如果没有更新呢，返回304。SD上面有一段对304的判断： 1234567891011121314//'304 Not Modified' is an exceptional oneif (![response respondsToSelector:@selector(statusCode)] || ([((NSHTTPURLResponse *)response) statusCode] &lt; 400 &amp;&amp; [((NSHTTPURLResponse *)response) statusCode] != 304)) &#123; NSInteger expected = response.expectedContentLength &gt; 0 ? (NSInteger)response.expectedContentLength : 0; self.expectedSize = expected; if (self.progressBlock) &#123; self.progressBlock(0, expected); &#125; self.imageData = [[NSMutableData alloc] initWithCapacity:expected]; self.response = response; dispatch_async(dispatch_get_main_queue(), ^&#123; [[NSNotificationCenter defaultCenter] postNotificationName:SDWebImageDownloadReceiveResponseNotification object:self]; &#125;);&#125; 如果是304，就说明没有新的图片。。。我们服务器估计没有304的判断，所以我也没有做验证，毕竟我是个新手，验证还是要靠你们，晚上8点了，就写这么多了，有问题的话大佬们指出下，我再去重新看一遍。]]></content>
      <tags>
        <tag>-OC进阶</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo新建文章操作]]></title>
    <url>%2F2016%2F04%2F28%2Fhexo%E6%96%B0%E5%BB%BA%E6%96%87%E7%AB%A0%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[个人博客不是经常会用，所以总是忘记Hexo的一些命令，最近重新捡起来，把发布新文章的操作从新纪录一下。 cd 到放置文章的_post目录下创建一篇新文章 hexo new post “xxx”执行发布命令 hexo clean 、 hexo d -g 上传完成、刷新页面，嗯嗯是不是发现404了。 CNAME 文件没了，域名指向。 网上都说创建CNMAE文件不要后缀，怎么创建呢？想了N种方法怕出错，直接终端vim就好了，把文件放到Hexo-blog-source目录下，这样下次就不用重新来生成了。 以下为本人脑残纪录，跟上述内容无关 阅读统计：LeanCloud 微博登录的。评论：来必力 手机号还是邮箱的忘掉了。图片：七牛云上配置 应该诗手记。]]></content>
      <tags>
        <tag>-hexo记录</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++创建新类如何关联到main.cpp上]]></title>
    <url>%2F2016%2F04%2F15%2FC-%E5%88%9B%E5%BB%BA%E6%96%B0%E7%B1%BB%E5%A6%82%E4%BD%95%E5%85%B3%E8%81%94%E5%88%B0main-cpp%E4%B8%8A%2F</url>
    <content type="text"><![CDATA[对于无C++基础的人来说，新建一个.h和.cpp如何与main.cpp关联是一脸懵逼的状态。 本人用mac的Xcode来学习C++的，所以创建的.hpp与.h是一个东西首先创建一个新类LJX_One.hpp和LJX_One.cpp LJX_One.hpp代码 12345678910111213141516#ifndef LJX_One_hpp#define LJX_One_hpp#include &lt;stdio.h&gt;class LJX &#123; public: LJX()&#123;&#125;; ~LJX()&#123;&#125;; public: int sort(); void compact(); void write();&#125;;#endif /* LJX_One_hpp */ LJX_One.cpp代码 123456789101112131415161718192021222324252627282930#include &lt;iostream&gt;#include "LJX_One.hpp"using namespace std;int LJX::sort()&#123; return 1;&#125;void LJX::compact()&#123; int ljx_count = 1024; int * ljx_isa = &amp;ljx_count; *ljx_isa = *ljx_isa + 1; cout &lt;&lt; ljx_count; cout &lt;&lt;"\n";&#125;void LJX::write()&#123; int *pi = new int( 0 ); int *pia = new int[ 10 ]; while ( *pi &lt; 10 ) &#123; pia[ *pi ] = *pi; cout &lt;&lt; pia[ *pi ] &lt;&lt; "\n"; *pi = *pi + 1; &#125; delete pi; delete [] pia;&#125; main.cpp中调用 12345678910111213141516171819#include &lt;iostream&gt;#include &lt;string&gt;#include "LJX_One.hpp"using namespace std;int main(int argc, const char * argv[]) &#123;LJX first;int count = first.sort();if (count == 0) &#123; first.compact();&#125; else &#123; first.write();&#125;return 0;&#125;]]></content>
      <tags>
        <tag>-C++初探</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[开始写博客]]></title>
    <url>%2F2016%2F03%2F05%2F%E5%BC%80%E5%A7%8B%E5%86%99%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[Blog。 个人感觉，现在的Github上em。。。所以现在很少上Github上down代码来看，都是在Stackoverflow瞎逛。 以前很多东西都是放在脑子里的，出现问题会微微的有一点印象，随便Google下，就可以了。最近工作不是那么稳定，有点想去大佬的地方呆呆，学习一点东西的想法。所以重拾个人博客，至于Github，自己搭建过很多的框架，每次都不满意，最近又开始新的旅程。等我在自己的水平上，搭建完自己满意的东西，会把平时用的都搞上去，然后在上传。亲们，我只是一个小渣渣，不好的地方请不要打我，先行谢过！！！]]></content>
      <tags>
        <tag>-杂记</tag>
      </tags>
  </entry>
</search>
