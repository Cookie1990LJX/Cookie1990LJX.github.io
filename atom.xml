<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Cookie&#39;s Blog</title>
  
  <subtitle>信念、追求、超越</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://lvjunxue.com/"/>
  <updated>2020-07-29T07:05:37.207Z</updated>
  <id>http://lvjunxue.com/</id>
  
  <author>
    <name>Cookie</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>将自己的framework发布到pod</title>
    <link href="http://lvjunxue.com/2020/07/03/%E5%B0%86%E8%87%AA%E5%B7%B1%E7%9A%84framework%E5%8F%91%E5%B8%83%E5%88%B0pod/"/>
    <id>http://lvjunxue.com/2020/07/03/将自己的framework发布到pod/</id>
    <published>2020-07-03T11:05:44.000Z</published>
    <updated>2020-07-29T07:05:37.207Z</updated>
    
    <content type="html"><![CDATA[<p>将自己的framework发布到pod</p><a id="more"></a><p>开始～～～～～～</p><p>git add .<br>git status<br>git commit -s -m “测试1”<br>git push cookie-cocospods master<br>git tag -m “测试1” “0.0.1”<br>git push –tags<br>pod lib lint  AdHubSDK-iOS-ads.podspec –allow-warnings –use-libraries –no-clean –verbose</p><p>pod spec lint  AdHubSDK-iOS-ads.podspec –allow-warnings –use-libraries –no-clean –verbose</p><p>pod trunk push AdHubSDK-iOS-ads.podspec –allow-warnings –use-libraries</p><p>pod setup<br>rm ~/Library/Caches/CocoaPods/search_index.json</p><p>pod repo update</p><p>pod search AdHubSDK</p><p>pod trunk delete AdHubSDK-iOS-ads 0.1.4</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;将自己的framework发布到pod&lt;/p&gt;
    
    </summary>
    
    
      <category term="-环境搭建" scheme="http://lvjunxue.com/tags/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    
  </entry>
  
  <entry>
    <title>C++创建新类如何关联到main.cpp上</title>
    <link href="http://lvjunxue.com/2020/06/02/git%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/"/>
    <id>http://lvjunxue.com/2020/06/02/git常用指令/</id>
    <published>2020-06-02T07:53:47.000Z</published>
    <updated>2020-08-14T08:37:03.796Z</updated>
    
    <content type="html"><![CDATA[<p>口吐芬芳，不可描述。</p><a id="more"></a><p>远程服务器分支列表 git branch -r<br>下载代码git clone <a href="mailto:git@code.aliyun.com" target="_blank" rel="noopener">git@code.aliyun.com</a>:adhub-sdk-ios/adsManager4.git</p><p>git checkout xxx</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;口吐芬芳，不可描述。&lt;/p&gt;
    
    </summary>
    
    
      <category term="git指令" scheme="http://lvjunxue.com/tags/git%E6%8C%87%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>C++初探</title>
    <link href="http://lvjunxue.com/2020/03/12/C++%E5%88%9D%E6%8E%A2/"/>
    <id>http://lvjunxue.com/2020/03/12/C++初探/</id>
    <published>2020-03-12T11:00:18.000Z</published>
    <updated>2020-03-13T08:20:41.866Z</updated>
    
    <content type="html"><![CDATA[<p>此文献给自己学习过程。</p><a id="more"></a><p>发现自己的水平没有提高，每天被各种会议，需求充斥着，打算重新捡起来，再学一遍OC。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;此文献给自己学习过程。&lt;/p&gt;
    
    </summary>
    
    
      <category term="-C++初探" scheme="http://lvjunxue.com/tags/C-%E5%88%9D%E6%8E%A2/"/>
    
  </entry>
  
  <entry>
    <title>几个警告消除</title>
    <link href="http://lvjunxue.com/2018/11/22/%E5%AF%BC%E5%87%BACrash/"/>
    <id>http://lvjunxue.com/2018/11/22/导出Crash/</id>
    <published>2018-11-22T09:01:17.000Z</published>
    <updated>2019-08-20T02:52:10.679Z</updated>
    
    <content type="html"><![CDATA[<p>导出崩溃日志</p><a id="more"></a><p>连接公司VPN</p><p>运行 ./esTool -x<br>如果出现没有权限，运行 chmod +x esTool<br>再次运行 ./esTool -x<br>显示：<br>Usage of ./esTool:<br>-et string<br>start time.  (default “2019-08-15 23:59:59”)<br>-st string<br>start time.  (default “2019-08-15 00:00:00”)<br>运行<br>./esTool -st “2019-08-15 00:00:00” -et “2019-08-20 08:00:00”</p><p>导出excl</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;导出崩溃日志&lt;/p&gt;
    
    </summary>
    
    
      <category term="杂记" scheme="http://lvjunxue.com/tags/%E6%9D%82%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>几个警告消除</title>
    <link href="http://lvjunxue.com/2018/11/22/%E5%87%A0%E4%B8%AA%E8%AD%A6%E5%91%8A%E6%B6%88%E9%99%A4/"/>
    <id>http://lvjunxue.com/2018/11/22/几个警告消除/</id>
    <published>2018-11-22T09:01:17.000Z</published>
    <updated>2019-03-12T08:21:37.721Z</updated>
    
    <content type="html"><![CDATA[<p>SDK开发过程的几个警告消除</p><a id="more"></a><p>iOS：warning (armv7) unable to open object file No such file or direc<br>Build Options的Debug Information Format 的DWARF</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;SDK开发过程的几个警告消除&lt;/p&gt;
    
    </summary>
    
    
      <category term="杂记" scheme="http://lvjunxue.com/tags/%E6%9D%82%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Xcode字体，颜色修改篇</title>
    <link href="http://lvjunxue.com/2018/11/22/%E5%AF%B9%E4%BA%8E%E4%B8%80%E4%B8%AA%E5%A4%84%E5%A5%B3%E5%BA%A7%E7%9A%84%E6%88%91/"/>
    <id>http://lvjunxue.com/2018/11/22/对于一个处女座的我/</id>
    <published>2018-11-22T09:01:17.000Z</published>
    <updated>2019-04-16T10:10:01.803Z</updated>
    
    <content type="html"><![CDATA[<p>处女座的我。。。你们懂得，记录一下。</p><a id="more"></a><p>字体：Menlo<br>颜色：<br>Comments-注释<br>Documentation-注释<br>Strings-字符串<br>Characters-字符<br>Numbers-数字<br>Keywords-关键字</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;处女座的我。。。你们懂得，记录一下。&lt;/p&gt;
    
    </summary>
    
    
      <category term="-iOS杂记" scheme="http://lvjunxue.com/tags/iOS%E6%9D%82%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>SDK开发记录</title>
    <link href="http://lvjunxue.com/2018/11/22/SDK%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/"/>
    <id>http://lvjunxue.com/2018/11/22/SDK开发记录/</id>
    <published>2018-11-22T09:01:17.000Z</published>
    <updated>2019-07-09T07:13:52.823Z</updated>
    
    <content type="html"><![CDATA[<p>SDK开发记录内容。有错误内容还请指出。</p><a id="more"></a><p>首先记录一些常用的终端指令：<br>cd到framework目录下之后<br>file 查看支持、动态库还是静态库，含有dynamically为动态库，否则为静态库<br>lipo -info 支持信息<br>lipo -create XXX XXX -output XXX合并framework</p><p>proto转oc文件，cd到src目录下运行以下指令<br>protoc –proto_path=/Users/Cookie/Desktop/iOS开发/pb转换/pb_AdHub –objc_out=/Users/Cookie/Desktop/iOS开发/pb转换/pb_AdHub adRequest.proto adResponse.proto bidExt.proto commonInfo.proto enumType.proto heartbeat.proto logRequest.proto reportRequest.proto</p><p>protoc –proto_path=/Users/Cookie/Desktop/iOS开发/pb转换/pb_haobo –objc_out=/Users/Cookie/Desktop/iOS开发/pb转换/pb_haobo adRequest.proto adResponse.proto bidExt.proto commonInfo.proto enumType.proto heartbeat.proto logRequest.proto reportRequest.proto</p><p>Demos</p><p>protoc –proto_path=/Users/Cookie/Desktop/iOS开发/pb转换/pb_AdHub –objc_out=/Users/Cookie/Desktop/iOS开发/pb转换/pb_AdHub heartbeat.proto</p><p>清理描述文件l命令：<br>cd ~/Library/MobileDevice/Provisioning\ Profiles/<br>rm *.mobileprovision</p><p>pod package AdHubSDK.podspec –force</p><p>–exclude-deps</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;SDK开发记录内容。有错误内容还请指出。&lt;/p&gt;
    
    </summary>
    
    
      <category term="-iOS进阶" scheme="http://lvjunxue.com/tags/iOS%E8%BF%9B%E9%98%B6/"/>
    
  </entry>
  
  <entry>
    <title>iOS基础</title>
    <link href="http://lvjunxue.com/2018/10/11/iOS%E5%9F%BA%E7%A1%80/"/>
    <id>http://lvjunxue.com/2018/10/11/iOS基础/</id>
    <published>2018-10-11T01:56:18.000Z</published>
    <updated>2018-10-25T04:25:47.645Z</updated>
    
    <content type="html"><![CDATA[<p>接上一个篇，iOS基础。以下答案均为自己想法，有一些答案没有往深处去挖，如有错误跪求指出。</p><h3 id=""><a href="#" class="headerlink" title=""></a><font color="#0099ff"></font></h3><a id="more"></a><h2 id="给你瞅瞅什么是开局一刀，后面把你砍成渣！！！"><a href="#给你瞅瞅什么是开局一刀，后面把你砍成渣！！！" class="headerlink" title="给你瞅瞅什么是开局一刀，后面把你砍成渣！！！"></a>给你瞅瞅什么是开局一刀，后面把你砍成渣！！！</h2><h3 id="property的本质是什么？"><a href="#property的本质是什么？" class="headerlink" title="@property的本质是什么？"></a><font color="#0099ff">@property的本质是什么？</font></h3><table><tr><td bgcolor="#1C1C1C"><font color="#DCDCDC">实例变量+get方法+set方法,也就是说使用@property系统会自动生成setter和getter方法。</font></td></tr></table><h3 id="property-后面可以有哪些修饰符？"><a href="#property-后面可以有哪些修饰符？" class="headerlink" title="@property 后面可以有哪些修饰符？"></a><font color="#0099ff">@property 后面可以有哪些修饰符？</font></h3><table><tr><td bgcolor="#1C1C1C"><font color="#DCDCDC">nonatomic，atomic，strong，copy，retain，weak，assign，readonly，writeonly，readwrite。</font></td></tr></table><h3 id="strong和copy的区别？copy和mutablecopy区别？"><a href="#strong和copy的区别？copy和mutablecopy区别？" class="headerlink" title="strong和copy的区别？copy和mutablecopy区别？"></a><font color="#0099ff">strong和copy的区别？copy和mutablecopy区别？</font></h3><table><tr><td bgcolor="#1C1C1C"><font color="#DCDCDC">源头不可变的strong和copy没区别，都是浅拷贝。源头可变的strong是浅，copy是深。其实这个很好记copy思想就是不能变。至于mutablecopy就是深，我可不管你能不能变。如果你还是不明白，你最好写一个小Demo去深入的看看结果。</font></td></tr></table><h3 id="如何让自己的类用-copy-修饰符？如何重写带-copy-关键字的-setter？"><a href="#如何让自己的类用-copy-修饰符？如何重写带-copy-关键字的-setter？" class="headerlink" title="如何让自己的类用 copy 修饰符？如何重写带 copy 关键字的 setter？"></a><font color="#0099ff">如何让自己的类用 copy 修饰符？如何重写带 copy 关键字的 setter？</font></h3><table><tr><td bgcolor="#1C1C1C"><font color="#DCDCDC">需声明该类遵从 NSCopying 协议<br>实现 NSCopying 协议的方法。该协议只有一个方法:- (id)copyWithZone:(NSZone *)zone;</font></td></tr></table><h3 id="weak和assign的区别？"><a href="#weak和assign的区别？" class="headerlink" title="weak和assign的区别？"></a><font color="#0099ff">weak和assign的区别？</font></h3><table><tr><td bgcolor="#1C1C1C"><font color="#DCDCDC">weak修饰的变量无野指针，释放的同时置空，访问不会crash。但只能修饰OC的对象。<br>assign可以用于非OC对象。</font></td></tr></table><h3 id="weak是如何置空的？"><a href="#weak是如何置空的？" class="headerlink" title="weak是如何置空的？"></a><font color="#0099ff">weak是如何置空的？</font></h3><table><tr><td bgcolor="#1C1C1C"><font color="#DCDCDC">runtime 对于 weak 对象会放入一个 hash 表中。 用 weak 指向的对象内存地址作为 key，当此对象的引用计数为0的时候会 dealloc，runtime调用clearDeallocating函数，假如 weak 指向的对象内存地址是a，那么就会以a为键， 在这个 weak 表中搜索，找到所有以a为键的 weak 对象，从而设置为 nil。</font></td></tr></table><h3 id="nonatomic和atomic的区别？"><a href="#nonatomic和atomic的区别？" class="headerlink" title="nonatomic和atomic的区别？"></a><font color="#0099ff">nonatomic和atomic的区别？</font></h3><table><tr><td bgcolor="#1C1C1C"><font color="#DCDCDC">在声明的时候如果不写，那么默认是atomic。<br>atomic线程安全，速度慢。系统生成的 getter/setter 会保证 get、set 操作的完整性，不受其他线程影响。比如，线程 A 的 getter 方法运行到一半，线程 B 调用了 setter：那么线程 A 的 getter 还是能得到一个完好无损的对象。如果多个线程同时操作 get、set 方法，最后 get 得到的值有多种可能。<br>只能保证get、set方法，所以对于可变集合来说，并不能保证其线程安全。<br>nonatomic线程不安全，速度快。如有两个线程访问同一个属性，会出现无法预料的结果</font></td></tr></table><h3 id="block和weak区别？"><a href="#block和weak区别？" class="headerlink" title="block和weak区别？"></a><font color="#0099ff"><strong>block和</strong>weak区别？</font></h3><table><tr><td bgcolor="#1C1C1C"><font color="#DCDCDC">1）block下循环引用的问题<br><strong>block本身并不能避免循环引用，避免循环引用需要在 block 内部把 </strong>block 修饰的obj置为nil<br><strong>weak可以避免循环引用，但是其会导致外部对象释放了之后，block 内部也访问不到这个对象的问题，我们可以通过在 block 内部声明一个 </strong>strong<br>的变量来指向 weakObj，使外部对象既能在 block 内部保持住，又能避免循环引用的问题<br>2）<strong>block 与 </strong>weak 功能上的区别。<br><strong>block 会持有该对象，即使超出了该对象的作用域，该对象还是会存在的，直到 block 对象从堆上销毁；而</strong>weak 仅仅是将该对象赋值给 weak 对象，当该对象销毁时，weak 对象将指向nil；<br><strong>block 可以让 block 修改局部变量，而 </strong>weak 不能。<br>另外，MRC中 <strong>block 是不会引起 retain；但在ARC中 </strong>block 则会引起 retain。所以ARC中应该使用 __weak。</font></td></tr></table><h3 id="block本质是什么？"><a href="#block本质是什么？" class="headerlink" title="block本质是什么？"></a><font color="#0099ff">block本质是什么？</font></h3><table><tr><td bgcolor="#1C1C1C"><font color="#DCDCDC">其实 Block 的本质是带有函数执行上下文环境的结构体，其中包含被调函数指针<br>定义完block之后，其实是创建了一个函数，在创建结构体的时候把函数的指针一起传给了block，所以之后可以拿出来调用。</font></td></tr></table><h3 id="block截获变量的特性应该怎样解释？"><a href="#block截获变量的特性应该怎样解释？" class="headerlink" title="block截获变量的特性应该怎样解释？"></a><font color="#0099ff">block截获变量的特性应该怎样解释？</font></h3><table><tr><td bgcolor="#1C1C1C"><font color="#DCDCDC">__block 所起到的作用就是只要观察到该变量被 block 所持有，就将“外部变量”在栈中的内存地址放到了堆中</font></td></tr></table><h3 id="block和delegate区别？"><a href="#block和delegate区别？" class="headerlink" title="block和delegate区别？"></a><font color="#0099ff">block和delegate区别？</font></h3><table><tr><td bgcolor="#1C1C1C"><font color="#DCDCDC">1）delegate 运行成本低，block 运行成本高。<br>block 出栈需要将使用的数据从栈内存拷贝到堆内存，使用完或者 block 置 nil 后被消除。delegate 只是保存了一个对象的指针，直接回调，没有额外消耗。<br>2）delegate 是 weak 弱引用；block 是 copy 修饰，强引用。delegate 更安全些，block 容易引起循环引用。<br>3）block 直接访问上下文，块和块实现在同一个地方，代码组织更加连贯。<br>delegate 声明和方法分离开来，代码的连贯性不是很好。</font></td></tr></table><h3 id="block种类？"><a href="#block种类？" class="headerlink" title="block种类？"></a><font color="#0099ff">block种类？</font></h3><table><tr><td bgcolor="#1C1C1C"><font color="#DCDCDC">_NSConcreteGlobalBlock 全局的静态 block，不会访问外部局部变量。<br>_NSConcreteMallocBlock 保存在堆中的 block，当引用计数为 0 时会被销毁。<br>_NSConcreteStackBlock 保存在栈中的 block，当函数返回时会被销毁。</font></td></tr></table><h3 id="delegate和Notification的区别？"><a href="#delegate和Notification的区别？" class="headerlink" title="delegate和Notification的区别？"></a><font color="#0099ff">delegate和Notification的区别？</font></h3><table><tr><td bgcolor="#1C1C1C"><font color="#DCDCDC">水平有限，我逛了一圈唯一发现的的就是1对1，1对多的不同，外加就是效率上 delegate 比较高，还有就是使用的时候看紧密程度，如果高就用 delegate 否则用 Notification，多线程里一般会用 Notification。</font></td></tr></table><h3 id="NSNotificationCenter的原理？"><a href="#NSNotificationCenter的原理？" class="headerlink" title="NSNotificationCenter的原理？"></a><font color="#0099ff">NSNotificationCenter的原理？</font></h3><table><tr><td bgcolor="#1C1C1C"><font color="#DCDCDC">NSNotificatinonCenter 是使用观察者模式来实现的用于跨层传递消息，用来降低耦合度。<br>NSNotificatinonCenter 用来管理通知，将观察者注册到 NSNotificatinonCenter 的通知调度表中，然后发送通知时利用标识符 name 和 object 识别出调度表中的观察者，然后调用相应的观察者的方法，即传递消息（在Objective-C中对象调用方法，就是传递消息，消息有 name 或者 selector，可以接受参数，而且可能有返回值），如果是基于 block 创建的通知就调用 NSNotification 的 block。</font></td></tr></table><h3 id="Notification使用的时候要注意什么？"><a href="#Notification使用的时候要注意什么？" class="headerlink" title="Notification使用的时候要注意什么？"></a><font color="#0099ff">Notification使用的时候要注意什么？</font></h3><table><tr><td bgcolor="#1C1C1C"><font color="#DCDCDC">Notification 使用的时候 add 和 remove 要成对的写。如果 add 之后没有 remove，那么你下次进来的时候，会通知2次。<br>还有同名的注册多少次，他的执行代码就会执行多少次，但是移除的时候会一次性全部移除。</font></td></tr></table><h3 id="KVC和KVO？"><a href="#KVC和KVO？" class="headerlink" title="KVC和KVO？"></a><font color="#0099ff">KVC和KVO？</font></h3><p>这个牛逼的，你想解释起来，那真是长篇大论，能说好久。</p><table><tr><td bgcolor="#1C1C1C"><font color="#DCDCDC">KVC 通过 Key 名直接访问对象的属性，或者给对象的属性赋值。<br>日常使用的地方：动态地取值和设值，访问和修改私有变量，Model 和字典转换，修改一些控件的内部属性</font></td></tr></table><table><tr><td bgcolor="#1C1C1C"><font color="#DCDCDC">KVO 其基本思想是，对目标对象的某属性添加观察，当该属性发生变化时，通过触发观察者对象实现的 KVO 接口方法，来自动的通知观察者。<br>日常使用的地方：你用MVVM嘛？</font></td></tr></table><h3 id="KVO原理？"><a href="#KVO原理？" class="headerlink" title="KVO原理？"></a><font color="#0099ff">KVO原理？</font></h3><table><tr><td bgcolor="#1C1C1C"><font color="#DCDCDC">KVO 是通过 isa-swizzling 实现的。<br>基本的流程就是编译器自动为被观察对象创造一个派生类，并将被观察对象的 isa 指向这个派生类。如果用户注册了对某此目标对象的某一个属性的观察，那么此派生类会重写这个方法，并在其中添加进行通知的代码。Objective-C 在发送消息的时候，会通过 isa 指针找到当前对象所属的类对象。而类对象中保存着当前对象的实例方法，因此在向此对象发送消息时候，实际上是发送到了派生类对象的方法。由于编译器对派生类的方法进行了 override，并添加了通知代码，因此会向注册的对象发送通知。注意派生类只重写注册了观察者的属性方法。<br>em？？？解释的迷迷糊糊一知半解，来来来咱们继续runtime走起！</font></td></tr></table><h3 id="什么是runtime？"><a href="#什么是runtime？" class="headerlink" title="什么是runtime？"></a><font color="#0099ff">什么是runtime？</font></h3><table><tr><td bgcolor="#1C1C1C"><font color="#DCDCDC">运行时，运行的时候决定具体要干什么</font></td></tr></table><h3 id="你都在什么地方使用过runtime"><a href="#你都在什么地方使用过runtime" class="headerlink" title="你都在什么地方使用过runtime"></a><font color="#0099ff">你都在什么地方使用过runtime</font></h3><table><tr><td bgcolor="#1C1C1C"><font color="#DCDCDC">分类添加属性，方法添加或替换。</font></td></tr></table><h3 id="runtime怎么添加属性、方法等"><a href="#runtime怎么添加属性、方法等" class="headerlink" title="runtime怎么添加属性、方法等"></a><font color="#0099ff">runtime怎么添加属性、方法等</font></h3><table><tr><td bgcolor="#1C1C1C"><font color="#DCDCDC">class_addIvar，class_addMethod，class_addProperty，class_addProtocol，class_replaceProperty</font></td></tr></table><h3 id="runtime如何通过selector找到对应的IMP地址？"><a href="#runtime如何通过selector找到对应的IMP地址？" class="headerlink" title="runtime如何通过selector找到对应的IMP地址？"></a><font color="#0099ff">runtime如何通过selector找到对应的IMP地址？</font></h3><table><tr><td bgcolor="#1C1C1C"><font color="#DCDCDC">类对象中有类方法和实例方法的列表，列表中记录着方法的名词、参数和实现，而selector本质就是方法名称，runtime通过这个方法名称就可以在列表中找到该方法对应的实现。还有缓存机制别忘了。</font></td></tr></table><h3 id="消息机制方法调用流程？"><a href="#消息机制方法调用流程？" class="headerlink" title="消息机制方法调用流程？"></a><font color="#0099ff">消息机制方法调用流程？</font></h3><table><tr><td bgcolor="#1C1C1C"><font color="#DCDCDC">对象方法：(保存到类对象的方法列表) ，类方法：(保存到元类(Meta Class)中方法列表)。<br>1）OC 在向一个对象发送消息时，runtime 库会根据对象的 isa 指针找到该对象对应的类或其父类中查找方法。<br>2）注册方法编号（这里用方法编号的好处，可以快速查找）。<br>3）根据方法编号去查找对应方法。<br>4）找到只是最终函数实现地址，根据地址去方法区调用对应函数。</font></td></tr></table><h3 id="消息转发？或者-objc-msgForward-干什么的？"><a href="#消息转发？或者-objc-msgForward-干什么的？" class="headerlink" title="消息转发？或者 _objc_msgForward 干什么的？"></a><font color="#0099ff">消息转发？或者 _objc_msgForward 干什么的？</font></h3><table><tr><td bgcolor="#1C1C1C"><font color="#DCDCDC">当向一个对象发送一条消息，但它并没有实现的时候，_objc_msgForward 会尝试做消息转发。消息转发的过程会调用几个方法<br>1）resolveInstanceMethod 是否动态的添加一个方法，添加提前结束消息转发，否则，继续执行<br>2）forwardingTargetForSelector 诶，兄弟有人能帮我实现不？转发给另一个对象有，提前结束，否则，继续执行<br>3）调用 methodSignatureForSelector 获取方法签名后，判断返回类型信息是否正确，再调用 forwardInvocation 执行 NSInvocation 对象，并将结果返回。如果对象没实现 methodSignatureForSelector 方法，进入最后一步。<br>4）doesNotRecognizeSelector 没人管！</font></td></tr></table><h3 id="什么是-runloop-？"><a href="#什么是-runloop-？" class="headerlink" title="什么是 runloop ？"></a><font color="#0099ff">什么是 runloop ？</font></h3><table><tr><td bgcolor="#1C1C1C"><font color="#DCDCDC">runloop是线程相关的的基础框架的一部分。一个 runloop 就是一个事件处理的循环，用来不停的调度工作以及处理输入事件。其实内部就是 do－while 循环，这个循环内部不断地处理各种任务。使用 runloop 的目的是让你的线程在有工作的时候忙于工作，而没工作的时候处于休眠状态。</font></td></tr></table><h3 id="NSRunLoop-和-CFRunLoopRef？"><a href="#NSRunLoop-和-CFRunLoopRef？" class="headerlink" title="NSRunLoop 和 CFRunLoopRef？"></a><font color="#0099ff">NSRunLoop 和 CFRunLoopRef？</font></h3><table><tr><td bgcolor="#1C1C1C"><font color="#DCDCDC">我们不能再一个线程中去操作另外一个线程的 runloop 对象，后果不可知。但是 CoreFundation 中的不透明类 CFRunLoopRef 是线程安全的，而且两种类型的 runloop 完全可以混合使用。<br>- (CFRunLoopRef)getCFRunLoop;<br>NSRunLoop是OC的API，线程不是安全的。<br>CFRunLoopRef提供的是C语言的API，线程安全。</font></td></tr></table><h3 id="runloop的mode作用是什么？"><a href="#runloop的mode作用是什么？" class="headerlink" title="runloop的mode作用是什么？"></a><font color="#0099ff">runloop的mode作用是什么？</font></h3><table><tr><td bgcolor="#1C1C1C"><font color="#DCDCDC">model 主要是用来指定事件在运行循环中的优先级的</font></td></tr></table><h3 id="什么地方使用过runloop？"><a href="#什么地方使用过runloop？" class="headerlink" title="什么地方使用过runloop？"></a><font color="#0099ff">什么地方使用过runloop？</font></h3><table><tr><td bgcolor="#1C1C1C"><font color="#DCDCDC">NSTimer、performSelecter:afterDelay:、事件响应、手势识别、界面更新</font></td></tr></table><h3 id="NSTimer使用时需要注意什么"><a href="#NSTimer使用时需要注意什么" class="headerlink" title="NSTimer使用时需要注意什么"></a><font color="#0099ff">NSTimer使用时需要注意什么</font></h3><table><tr><td bgcolor="#1C1C1C"><font color="#DCDCDC">保证开启runloop，如果在滑动页面保证model切换成NSRunLoopCommonModes。不使用的时候销毁。</font></td></tr></table><h3 id="runloop-和线程有什么关系？"><a href="#runloop-和线程有什么关系？" class="headerlink" title="runloop 和线程有什么关系？"></a><font color="#0099ff">runloop 和线程有什么关系？</font></h3><table><tr><td bgcolor="#1C1C1C"><font color="#DCDCDC">runloop与线程是一一对应的，可以这样说 runloop 是为了线程而生，没有线程，它就没有存在的必要。一个runloop对应一个核心的线程，为什么说是核心的，是因为runloop是可以嵌套的，但是核心的只能有一个，他们的关系保存在一个全局的字典里。</font></td></tr></table><h3 id="GCD和NSOperation的区别？"><a href="#GCD和NSOperation的区别？" class="headerlink" title="GCD和NSOperation的区别？"></a><font color="#0099ff">GCD和NSOperation的区别？</font></h3><table><tr><td bgcolor="#1C1C1C"><font color="#DCDCDC">1）NSOperation是对GCD的封装，GCD是C语言的API。<br>2）NSOperation可以设置两个NSOperation之间的依赖，GCD无法设置依赖关系，不过可以通过dispatch_barrier_async来实现。<br>3）NSOperation和容易判断Operation当前的状态(是否执行，是否取消)，对此GCD无法通过KVO进行判断<br>4）NSOperation可以设置自身的优先级，但是优先级高的不一定先执行，GCD只能设置队列的优先级，无法在执行的block设置优先级。<br>5）NSOperation是一个抽象类实际开发中常用的两个类是NSInvocationOperation和NSBlockOperation，同样我们可以自定义NSOperation，GCD执行任务可以自由组装，没有继承那么高的代码复用度。<br>总结：直接使用GCD效率确实会更高效，NSOperation会多一点开销，但是通过NSOperation可以获得依赖，优先级，继承，键值对观察这些优势</font></td></tr></table><h3 id="GCD中dispatch-barrier-async做什么的？"><a href="#GCD中dispatch-barrier-async做什么的？" class="headerlink" title="GCD中dispatch_barrier_async做什么的？"></a><font color="#0099ff">GCD中dispatch_barrier_async做什么的？</font></h3><table><tr><td bgcolor="#1C1C1C"><font color="#DCDCDC">在它前面的任务执行结束后它才执行，它后面的任务要等它执行完成后才会开始执行。</font></td></tr></table><h3 id="如何用GCD同步若干个异步调用？"><a href="#如何用GCD同步若干个异步调用？" class="headerlink" title="如何用GCD同步若干个异步调用？"></a><font color="#0099ff">如何用GCD同步若干个异步调用？</font></h3><table><tr><td bgcolor="#1C1C1C"><font color="#DCDCDC">dispatch_group_notify</font></td></tr></table><h3 id="如何使用队列来避免资源抢夺？"><a href="#如何使用队列来避免资源抢夺？" class="headerlink" title="如何使用队列来避免资源抢夺？"></a><font color="#0099ff">如何使用队列来避免资源抢夺？</font></h3><table><tr><td bgcolor="#1C1C1C"><font color="#DCDCDC">加锁。<br>自旋锁<br>OSSpinLock 自旋锁(虽然已经被证明不安全 优先级翻转)，性能最高的锁。原理很简单，就是一直 do while 忙等。它的缺点是当等待时会消耗大量 CPU 资源，所以它不适用于较长时间的任务<br>苹果后来出个os_unfair_lock_t，这个锁解决了优先级反转问题。<br>互斥锁<br>NSLock；@synchronized atomic的setter方法用的就是它。与自旋区别就是有新的资源访问会被休眠等待，不会 do while 一直询问。<br>条件锁<br>根据解锁条件访问下一个锁内容。<br>递归锁<br>NSRecursiveLock可以被一个线程多次获得，而不会引起死锁。它记录了成功获得锁的次数，每一次成功的获得锁，必须有一个配套的释放锁和其对应，这样才不会引起死锁。只有当所有的锁被释放之后，其他线程才可以获得锁<br>信号量<br>初始化的时候确定并行数量。一个任务进去dispatch_semaphore_wait，数量减少一个，dispatch_semaphore_signal数量增加一个。<br>栏栅。</font></td></tr></table><h3 id="苹果为什么要废弃dispatch-get-current-queue？"><a href="#苹果为什么要废弃dispatch-get-current-queue？" class="headerlink" title="苹果为什么要废弃dispatch_get_current_queue？"></a><font color="#0099ff">苹果为什么要废弃dispatch_get_current_queue？</font></h3><table><tr><td bgcolor="#1C1C1C"><font color="#DCDCDC">容易造成死锁</font></td></tr></table><h3 id="AutoreleasePool实现原理"><a href="#AutoreleasePool实现原理" class="headerlink" title="AutoreleasePool实现原理?"></a><font color="#0099ff">AutoreleasePool实现原理?</font></h3><table><tr><td bgcolor="#1C1C1C"><font color="#DCDCDC">Autorelease pool implementation<br>A thread’s autorelease pool is a stack of pointers.<br>Each pointer is either an object to release, or POOL_SENTINEL which is an autorelease pool boundary.<br>A pool token is a pointer to the POOL_SENTINEL for that pool. When the pool is popped, every object hotter than the sentinel is released.<br>The stack is divided into a doubly-linked list of pages. Pages are added and deleted as necessary.<br>Thread-local storage points to the hot page, where newly autoreleased objects are stored.</font></td></tr></table><table><tr><td bgcolor="#1C1C1C"><font color="#DCDCDC">一个线程的autoreleasepool就是一个指针栈。<br>栈中存放的指针指向加入需要release的对象或者哨兵（哨兵对象，用于分隔autoreleasepool）<br>栈中指向哨兵的指针就是autoreleasepool的一个标记。当autoreleasepool进行出栈操作，每一个比这个哨兵对象后进栈的对象都会release。<br>里面的结构是一个双向链表组成。<br>autoreleasepool对应的线程存储了指向最新page（也就是最新添加autorelease对象的page）的指针。</font></td></tr></table><h3 id="NSTimer如果重复调用怎样解除循环引用？"><a href="#NSTimer如果重复调用怎样解除循环引用？" class="headerlink" title="NSTimer如果重复调用怎样解除循环引用？"></a><font color="#0099ff">NSTimer如果重复调用怎样解除循环引用？</font></h3><table><tr><td bgcolor="#1C1C1C"><font color="#DCDCDC">以前没看YYModel的时候，我都是在要销毁的地方手动干掉这个循环引用。<br>后来看了大神的开源库我发现了新的方式：<br>NSProxy不是NSObject子类，是一个变身卡。可以改变成任何对象。<br>让NSTimer持有NSProxy，NSProxy发送给需要定时器的对象。</font></td></tr></table><h3 id="instruments检测"><a href="#instruments检测" class="headerlink" title="instruments检测"></a><font color="#0099ff">instruments检测</font></h3><table><tr><td bgcolor="#1C1C1C"><font color="#DCDCDC">profile -&gt; instruments -&gt; Time Profiler<br>profile -&gt; instruments -&gt; Leaks</font></td></tr></table><h3 id="内存优化"><a href="#内存优化" class="headerlink" title="内存优化"></a><font color="#0099ff">内存优化</font></h3><table><tr><td bgcolor="#1C1C1C"><font color="#DCDCDC">首先检测是否有内存泄漏，日常开发过程中可以使用MLeaksFinder来检测，最后整体分析的时候使用instruments来做。<br>日常经常遇到的内存泄漏，大体上是循环引用，比如定时器、block、通知；死循环，比如一个动画设置了无限大的次数；大次数循环内存暴涨，处理方式加个自动释放池。<br>除去内存泄漏外，内存中大部分是因为图片占用的imageNamed会在内存中保存，直到被程序运行结束或系统调用内存警告被释放掉。如果使用imageWithContentsOfFile销毁的时候会释放出这块内存。<br>如果用SD处理大量图片的时候，记住在didReceiveMemoryWarning方法里释放掉图片的内存。</font></td></tr></table><h3 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a><font color="#0099ff">性能优化</font></h3><table><tr><td bgcolor="#1C1C1C"><font color="#DCDCDC">拿一个tableView来说事。都有哪些优化点。<br>1）复用，这个你要是不会，那咱还是回家干点别的吧。<br>2）图片的异步加载。<br>3）提前计算高度，缓存高度。<br>4）异步绘制。–扩展图片在渲染的过程，首先要把图片解码成位图，这个过程是耗时的，异步解码会优化很多性能。<br>以上的基本上可以满足，如果还不行。。。<br>5）按需加载，这个会有一个问题，就是快速滑动的时候，就会出现空白。</font></td></tr></table><h3 id="socket和webSocket"><a href="#socket和webSocket" class="headerlink" title="socket和webSocket"></a><font color="#0099ff">socket和webSocket</font></h3><table><tr><td bgcolor="#1C1C1C"><font color="#DCDCDC">Socket不是协议、是对TCP/IP封装的API。此处还在整理中。。。</font></td></tr></table><h2 id="接下来写一点我面试中遇到的问题吧。"><a href="#接下来写一点我面试中遇到的问题吧。" class="headerlink" title="接下来写一点我面试中遇到的问题吧。"></a>接下来写一点我面试中遇到的问题吧。</h2><h3 id="main函数前后都做了什么，什么影响app的启动速度"><a href="#main函数前后都做了什么，什么影响app的启动速度" class="headerlink" title="main函数前后都做了什么，什么影响app的启动速度"></a><font color="#0099ff">main函数前后都做了什么，什么影响app的启动速度</font></h3><table><tr><td bgcolor="#1C1C1C"><font color="#DCDCDC">main函数前，动态库加载，资源文件加载，runtime和load方法初始化<br>1）执行 Main<br>2）执行 UIApplicationMain 函数，创建 UIApplication 对象，并设置 UIApplicationMain 对象的代理。UIApplication 的第三个参数就是 UIApplication 的名称，如果指定为nil，它会默认为 UIApplication。UIApplication 的第四个参数为 UIApplication 的代理。<br>3）开启一个主运行循环，保证应用程序不退出。<br>4）加载 info.plist。<br>5）加载配置文件。判断一下 info.plist 文件当中有没有 Main storyboard file base name，里面有没有指定 Storyboard 文件，如果有就去加载 info.plist 文件，如果没有，那么应用程序加载完毕。<br>+load方法，动态库数量都会影响app启动速度。</font></td></tr></table><h3 id="http和https区别？"><a href="#http和https区别？" class="headerlink" title="http和https区别？"></a><font color="#0099ff">http和https区别？</font></h3><table><tr><td bgcolor="#1C1C1C"><font color="#DCDCDC">1）http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。<br>2）http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。<br>3）http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。</font></td></tr></table><h3 id="青花瓷如何抓包的？如何防止中间人抓包？"><a href="#青花瓷如何抓包的？如何防止中间人抓包？" class="headerlink" title="青花瓷如何抓包的？如何防止中间人抓包？"></a><font color="#0099ff">青花瓷如何抓包的？如何防止中间人抓包？</font></h3><table><tr><td bgcolor="#1C1C1C"><font color="#DCDCDC">青花瓷会让你装一个证书，本身手机会信任自身的所有证书，如果服务器没有校验证书的话，青花瓷拿着安装的证书去跟服务器拿数据，然后发给app。<br>SSL证书双向绑定验证身份，防止应用被抓包。</font></td></tr></table><h3 id="category和extension区别？"><a href="#category和extension区别？" class="headerlink" title="category和extension区别？"></a><font color="#0099ff">category和extension区别？</font></h3><table><tr><td bgcolor="#1C1C1C"><font color="#DCDCDC">category<br>可以在不修改原来类的基础上，为一个类扩展方法。如果想扩展属性，runtime写get、set方法。<br>extension<br>匿名扩展类，给一个添加私有方法和变量，是不是不知道具体是啥。你查看你的.m文件里面是不是有@interface，其实这就是一个，不信的话你自己创建一个试试。</font></td></tr></table><h3 id="category为什么不能添加属性？"><a href="#category为什么不能添加属性？" class="headerlink" title="category为什么不能添加属性？"></a><font color="#0099ff">category为什么不能添加属性？</font></h3><table><tr><td bgcolor="#1C1C1C"><font color="#DCDCDC">category是可以添加方法，不能添加实例变量对吧！之所以不能添加实例变量，是因为一个类的实例变量在编译阶段，就会在objc_class的class_ro_t这里进行存储和布局，而category是在运行时才进行加载的，运行时加载的时候 class_ro_t里面的方法、协议、属性等内容赋值给 class_rw_t，而 class_rw_t里面没有用来存储相关变量的数组，这样的结构也就注定实例变量是无法在运行期进行填充。</font></td></tr></table><h3 id="category添加属性之后不实现get、set方法会如何？"><a href="#category添加属性之后不实现get、set方法会如何？" class="headerlink" title="category添加属性之后不实现get、set方法会如何？"></a><font color="#0099ff">category添加属性之后不实现get、set方法会如何？</font></h3><table><tr><td bgcolor="#1C1C1C"><font color="#DCDCDC">报警告，运行使用到会出现crash</font></td></tr></table><table><tr><td bgcolor="#1C1C1C"><font color="#DCDCDC">关于这个的解释美团的一篇Blog写的很好<a href="https://tech.meituan.com/DiveIntoCategory.html" target="_blank" rel="noopener">这里是美团的连接</a></font></td></tr></table><h3 id="响应链？"><a href="#响应链？" class="headerlink" title="响应链？"></a><font color="#0099ff">响应链？</font></h3><table><tr><td bgcolor="#1C1C1C"><font color="#DCDCDC">创建一条响应链开始于第一响应者，结束于application，如果一个响应者不能处理事件，则会将事件沿着响应链传到下一响应者。<br>系统是通过以下2个方法知道哪个View响应点击事件的<br>- (UIView <em>)hitTest:(CGPoint)point withEvent:(UIEvent </em>)event<br>- (BOOL)pointInside:(CGPoint)point withEvent:(UIEvent *)event<br>你可以改变响应链通过重写你的响应对象的nextResponder属性。当你这样做了之后，下一个响应者就是你设置的。</font></td></tr></table><h3 id="如何高效的画一个圆角？"><a href="#如何高效的画一个圆角？" class="headerlink" title="如何高效的画一个圆角？"></a><font color="#0099ff">如何高效的画一个圆角？</font></h3><table><tr><td bgcolor="#1C1C1C"><font color="#DCDCDC">使用贝塞尔曲线UIBezierPath和Core Graphics框架画出一个圆角。<br>使用CAShapeLayer和UIBezierPath设置圆角。</font></td></tr></table><h3 id="UI绘制原理是怎样的？或卡顿的原因？"><a href="#UI绘制原理是怎样的？或卡顿的原因？" class="headerlink" title="UI绘制原理是怎样的？或卡顿的原因？"></a><font color="#0099ff">UI绘制原理是怎样的？或卡顿的原因？</font></h3><table><tr><td bgcolor="#1C1C1C"><font color="#DCDCDC">每个VSync之间有时间间隔，iOS 设备上是16.6ms。在这个时间内，CPU主线程计算布局，解码图片，创建视图，绘制文本，计算完成后将内容交给GPU，GPU合成，渲染，放入帧缓冲区，无论CPU和GPU哪个没有来得及生产出一帧缓冲，那么这一帧会被丢弃，显示器就会保持不变，继续显示上一帧内容，这导致画面卡顿。<br>为了解决效率问题，显示系统通常会引入两个缓冲区，GPU 会预先渲染好一帧放入一个缓冲区内，下一帧渲染完成。</font></td></tr></table><h3 id="UIView和CALayer的区别？"><a href="#UIView和CALayer的区别？" class="headerlink" title="UIView和CALayer的区别？"></a><font color="#0099ff">UIView和CALayer的区别？</font></h3><table><tr><td bgcolor="#1C1C1C"><font color="#DCDCDC">1）UIView继承UIResponder，所以能响应事件；CALyaer继承NSObject，不能响应事件。<br>2）每个UIview内部都有一个CALayer在背后提供内容的绘制和显示，并且UIview的尺寸样式都是由内部的layer提供。<br>3）在 View显示的时候，UIView 做为 Layer 的CALayerDelegate,View 的显示内容取决于内部的 CALayer 的 display<br>4）CALayer 是默认修改属性支持隐式动画的，在给 UIView 的 Layer 做动画的时候，View 作为 Layer 的代理，Layer 通过 actionForLayer:forKey:向 View请求相应的action(动画行为)<br>5）layer 内部维护着三分 layer tree,分别是 presentLayer Tree(动画树),modeLayer Tree(模型树), Render Tree (渲染树),在做 iOS动画的时候，我们修改动画的属性，在动画的其实是 Layer 的 presentLayer的属性值,而最终展示在界面上的其实是提供 View的modelLayer</font></td></tr></table><h3 id="iOS推送的原理"><a href="#iOS推送的原理" class="headerlink" title="iOS推送的原理"></a><font color="#0099ff">iOS推送的原理</font></h3><table><tr><td bgcolor="#1C1C1C"><font color="#DCDCDC">苹果的推送服务通知是由自己专门的推送服务器APNs （Apple Push Notification service）来完成的，其过程是 APNs 接收到我们自己的应用服务器发出的被推送的消息，将这条消息推送到指定的 iOS 的设备上，然后再由 iOS设备通知到我们的应用程序，我们将会以通知或者声音的形式收到推送回来的消息。 iOS 远程推送的前提是，装有我们应用程序的 iOS 设备，需要向 APNs 服务器注册，注册成功后，APNs 服务器将会给我们返回一个 devicetoken，我们获取到这个 token 后会将这个 token 发送给我们自己的应用服务器。当我们需要推送消息时，我们的应用服务器将消息按照指定的格式进行打包，然后结合 iOS 设备的 devicetoken 一起发给 APNs 服务器。我们的应用会和 APNs 服务器维持一个基于 TCP 的长连接，APNs 服务器将新消息推送到iOS 设备上，然后在设备屏幕上显示出推送的消息。</font></td></tr></table><h3 id="iOS-app启动的方式有哪些"><a href="#iOS-app启动的方式有哪些" class="headerlink" title="iOS app启动的方式有哪些"></a><font color="#0099ff">iOS app启动的方式有哪些</font></h3><table><tr><td bgcolor="#1C1C1C"><font color="#DCDCDC">自己启动（用户手动点击启动）<br>urlscheme启动（关于urlScheme的详解点击打开链接）<br>本地通知启动 （自己写的本地通知启动，蓝牙模块的启动，地理围栏的启动）<br>远程通知启动 （后台服务器的推送通知）</font></td></tr></table><h3 id="对数组循环时删除问题"><a href="#对数组循环时删除问题" class="headerlink" title="对数组循环时删除问题"></a><font color="#0099ff">对数组循环时删除问题</font></h3><table><tr><td bgcolor="#1C1C1C"><font color="#DCDCDC">forin的时候对数组进行删减工作会崩溃，如果加上break就不会了， for条件的时候不会，使用enumerateObjectsUsingBlock的时候不会。<br>快速遍历的原理是根据enumerator对象内部的计数器,调用nextObject方法来实现返回下一个数组元素的,直到元素全部返回就会返回nil,于是整个enumerator对象就遍历完了;同时也提醒,以这种原理来遍历enumerator对象的话,无论对这个对象做什么操作,对象的计数器都不会被重置!<br>由此就明白了,可能是我们在快速遍历的时候,移除掉一个元素,但是计数器依旧是原来的,那么在遍历到最后会继续调用nextObject方法,而此时实际上已经全部遍历完了,但是系统并不知道,还在遍历,也就是越界;当发现没有元素时,就crash了<br>使用另一个for循环或者enumerateObjectsUsingBlock不会出现crash</font></td></tr></table><h3 id="根据View获取当前的UIViewController"><a href="#根据View获取当前的UIViewController" class="headerlink" title="根据View获取当前的UIViewController"></a><font color="#0099ff">根据View获取当前的UIViewController</font></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (UIViewController *)viewControllerSupportView:(UIView *)view &#123;</span><br><span class="line">    for (UIView* next = [view superview]; next; next = next.superview) &#123;</span><br><span class="line">        UIResponder *nextResponder = [next nextResponder];</span><br><span class="line">        if ([nextResponder isKindOfClass:[UIViewController class]]) &#123;</span><br><span class="line">            return (UIViewController *)nextResponder;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return nil;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;接上一个篇，iOS基础。以下答案均为自己想法，有一些答案没有往深处去挖，如有错误跪求指出。&lt;/p&gt;
&lt;h3 id=&quot;&quot;&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title=&quot;&quot;&gt;&lt;/a&gt;&lt;font color=&quot;#0099ff&quot;&gt;&lt;/font&gt;&lt;/h3&gt;
    
    </summary>
    
    
      <category term="-iOS基础" scheme="http://lvjunxue.com/tags/iOS%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>数据算法</title>
    <link href="http://lvjunxue.com/2018/10/10/%E6%95%B0%E6%8D%AE%E7%AE%97%E6%B3%95/"/>
    <id>http://lvjunxue.com/2018/10/10/数据算法/</id>
    <published>2018-10-10T06:43:15.000Z</published>
    <updated>2018-10-11T01:55:20.360Z</updated>
    
    <content type="html"><![CDATA[<p>最近面试，被虐的很惨，实话实说，日常开发的东西基本上都会，有些不会的直接在stackoverflow上随便找找基本上都可以解决问题。面试的时候很多都是基础，平时遇见问题，google一下就带过了，也不会特意的背代码，很多问题都是碰见过，能解决，具体过程是真的忘了。所以有了以下这篇文章，想来一篇算法的，在来一份基础面试题，再之后写一篇面试的小问题吧。还有有一些答案不是最好的如果您有更好的，请给我留言，大家一起进步。—–来自一个非计算机专业的小白整理，请勿嘲笑。</p><a id="more"></a><p>1、交换A和B两个值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">用中间参数</span><br><span class="line">void swap(int a, int b) &#123;</span><br><span class="line">    int temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br><span class="line">不用中间参数</span><br><span class="line">void swap(int a, int b) &#123;</span><br><span class="line">    a = a + b;</span><br><span class="line">    b = a - b;</span><br><span class="line">    a = a - b;</span><br><span class="line">&#125;</span><br><span class="line">void swap(int a, int b) &#123;</span><br><span class="line">    a = a ^ b;</span><br><span class="line">    b = a ^ b;</span><br><span class="line">    a = a ^ b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>2、模拟栈操作<br>栈是一种数据结构，特点：先进后出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">栈最多能保存1024个数据</span><br><span class="line">static int data[1024];</span><br><span class="line">目前已经放了多少个数</span><br><span class="line">static int count = 0;</span><br><span class="line">数据入栈 push</span><br><span class="line">void push(int x) &#123;</span><br><span class="line">    防止数组越界</span><br><span class="line">    assert(!full());</span><br><span class="line">    data[count++] = x;</span><br><span class="line">&#125;</span><br><span class="line">数据出栈 pop</span><br><span class="line">int pop() &#123;</span><br><span class="line">    assert(!empty());</span><br><span class="line">    return data[--count];</span><br><span class="line">&#125;</span><br><span class="line">查看栈顶元素 top</span><br><span class="line">int top() &#123;</span><br><span class="line">    assert(!empty());</span><br><span class="line">    return data[count-1];</span><br><span class="line">&#125;</span><br><span class="line">查询栈满 full</span><br><span class="line">bool full() &#123;</span><br><span class="line">    if(count &gt;= 1024) &#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">查询栈空 empty</span><br><span class="line">bool empty() &#123;</span><br><span class="line">    if(count &lt;= 0) &#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    入栈</span><br><span class="line">    for (int i = 1; i &lt;= 10; i++) &#123;</span><br><span class="line">        push(i);</span><br><span class="line">    &#125;</span><br><span class="line">    出栈</span><br><span class="line">    while(!empty()) &#123;</span><br><span class="line">        栈顶元素</span><br><span class="line">        printf(&quot;%d &quot;, top());</span><br><span class="line">        出栈</span><br><span class="line">        pop();</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>3、排序<br>冒泡排序<br>最差时间复杂度 O(n^2)<br>平均时间复杂度 O(n^2)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (void)bubbleAscendingOrderSortWithArray:(NSMutableArray *)arr &#123;</span><br><span class="line">    for (int i = 0; i &lt; arr.count; i++) &#123;</span><br><span class="line">        for (int j = 0; j &lt; arr.count - 1 - i;j++) &#123;</span><br><span class="line">            if ([arr[j+1] intValue] &lt; [arr[j] intValue]) &#123;</span><br><span class="line">                int temp = [arr[j] intValue];</span><br><span class="line">                arr[j] = arr[j + 1];</span><br><span class="line">                arr[j + 1] = [NSNumber numberWithInt:temp];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>选择排序<br>平均时间复杂度：O(n^2)<br>平均空间复杂度：O(1)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">- (void)selectionAscendingOrderSortWithArray:(NSMutableArray *)arr &#123;</span><br><span class="line">    for (int i = 0; i &lt; arr.count; i ++) &#123;</span><br><span class="line">        int index = i;</span><br><span class="line">        for (int j = i + 1; j &lt; arr.count; j ++) &#123;</span><br><span class="line">            if ([arr[index] intValue] &gt; [arr[j] intValue]) &#123;</span><br><span class="line">                index = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(index != i) &#123;</span><br><span class="line">            int temp = [arr[i] intValue];</span><br><span class="line">            arr[i] = arr[index];</span><br><span class="line">            arr[index] = [NSNumber numberWithInt:temp];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>插入排序<br>平均时间复杂度：O(n^2)<br>平均空间复杂度：O(1)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (void)insertionAscendingOrderSort:(NSMutableArray *)arr &#123;</span><br><span class="line">    for (int i = 1; i &lt; arr.count; i ++) &#123;</span><br><span class="line">        int temp = [arr[i] intValue];</span><br><span class="line">        for (int j = i - 1; j &gt;= 0 &amp;&amp; temp &lt; [arr[j] intValue]; j --) &#123;</span><br><span class="line">            arr[j + 1] = arr[j];</span><br><span class="line">            arr[j] = [NSNumber numberWithInteger:temp];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>快速排序<br>平均时间复杂度：O(n^2)<br>平均空间复杂度：O(nlogn)       O(nlogn)~O(n^2)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">- (void)quickSortArray:(NSMutableArray *)array withLeftIndex:(NSInteger)leftIndex andRightIndex:(NSInteger)rightIndex &#123;</span><br><span class="line">    if (leftIndex &gt;= rightIndex) &#123;</span><br><span class="line">        return ;</span><br><span class="line">    &#125;</span><br><span class="line">    NSInteger i = leftIndex;</span><br><span class="line">    NSInteger j = rightIndex;</span><br><span class="line">    NSInteger key = [array[i] intValue];</span><br><span class="line">    while (i &lt; j) &#123;</span><br><span class="line">        while (i &lt; j &amp;&amp; [array[j] intValue] &gt;= key) &#123;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        array[i] = array[j];</span><br><span class="line">        while (i &lt; j &amp;&amp; [array[i] intValue] &lt;= key) &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        array[j] = array[i];</span><br><span class="line">    &#125;</span><br><span class="line">    array[i] = @(key);</span><br><span class="line">    [self quickSortArray:array withLeftIndex:leftIndex andRightIndex:i - 1];</span><br><span class="line">    [self quickSortArray:array withLeftIndex:i + 1 andRightIndex:rightIndex];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>希尔排序<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p><p>4、逆序字符串<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">不开辟空间新建字符串</span><br><span class="line">char* Reverse(char* s) &#123;</span><br><span class="line">    char* q = s ;</span><br><span class="line">    while( *q++ ) ;</span><br><span class="line">    q -= 2 ; </span><br><span class="line"></span><br><span class="line">    char* p = newchar[sizeof(char) * (q - s + 2)] ; </span><br><span class="line">    char* r = p ;</span><br><span class="line"></span><br><span class="line">    while(q &gt;= s)</span><br><span class="line">    *p++ = *q-- ;</span><br><span class="line">    *p = &apos;\0&apos; ;</span><br><span class="line"></span><br><span class="line">    return r ;</span><br><span class="line">&#125;</span><br><span class="line">中间字符串</span><br><span class="line">- (NSString*)reverseWordsInString:(NSString*)oldStr &#123;</span><br><span class="line">    NSMutableString *newStr = [[NSMutableString alloc] initWithCapacity:oldStr.length];</span><br><span class="line">    for (int i = oldStr.length - 1; i &gt;= 0; i --) &#123;</span><br><span class="line">        unichar character = [oldStr characterAtIndex:i];</span><br><span class="line">        [newStr appendFormat:@&quot;%c&quot;,character];</span><br><span class="line">    &#125;</span><br><span class="line">    return newStr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>5、链表翻转<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">node* reverseList(node* H) &#123; </span><br><span class="line">    if (H == NULL || H-&gt;next == NULL) //链表为空或者仅1个数直接返回</span><br><span class="line">    return H;</span><br><span class="line">    node* p = H, *newH = NULL; </span><br><span class="line">    while (p != NULL) //一直迭代到链尾 &#123; </span><br><span class="line">        node* tmp = p-&gt;next; //暂存p下一个地址，防止变化指针指向后找不到后续的数</span><br><span class="line">        p-&gt;next = newH; //p-&gt;next指向前一个空间 </span><br><span class="line">        newH = p; //新链表的头移动到p，扩长一步链表 </span><br><span class="line">        p = tmp; //p指向原始链表p指向的下一个空间 </span><br><span class="line">    &#125; </span><br><span class="line">    return newH; </span><br><span class="line">&#125;</span><br><span class="line">递归方式</span><br><span class="line">node* In_reverseList(node* H) &#123; </span><br><span class="line">    if (H == NULL || H-&gt;next == NULL) //链表为空直接返回，而H-&gt;next为空是递归基 </span><br><span class="line">        return H; </span><br><span class="line">    node* newHead = In_reverseList(H-&gt;next); //一直循环到链尾</span><br><span class="line">    H-&gt;next-&gt;next = H; //翻转链表的指向 </span><br><span class="line">    H-&gt;next = NULL; //记得赋值NULL，防止链表错乱 </span><br><span class="line">    return newHead; //新链表头永远指向的是原链表的链尾</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>6、求最大公约数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">int gcd(int a, int b) &#123;</span><br><span class="line">    int temp = 0;</span><br><span class="line">    if (a &lt; b) &#123;</span><br><span class="line">        temp = a;</span><br><span class="line">        a = b;</span><br><span class="line">        b = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    while (b != 0) &#123;</span><br><span class="line">        temp = a % b;</span><br><span class="line">        a = b;</span><br><span class="line">        b = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    return a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>7、从1亿个浮点数里找出最大的10个<br>第一想法都是排序之后再取前10个，但是呢效率不行。本人第二想法就是取前十个排序，在从剩下的一个一个替换掉，最后得到10个最大的数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (void)findMaxNum:(NSMutableArray *)arr &#123;</span><br><span class="line">    NSMutableArray * myArr = [[NSMutableArray alloc] initWithArray:[arr subarrayWithRange:NSMakeRange(0, 10)]];</span><br><span class="line">    [self quickSortArray:myArr withLeftIndex:0 andRightIndex:myArr.count - 1];</span><br><span class="line">    for (int i = 10; i &lt; arr.count - 1; i++) &#123;</span><br><span class="line">        if ([arr[i] intValue] &gt; [myArr[0] intValue]) &#123;</span><br><span class="line">            myArr[0] = arr[i];</span><br><span class="line">            [self quickSortArray:myArr withLeftIndex:0 andRightIndex:myArr.count - 1];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>8、数组去重<br>如果是OC的话，可以用NSSet的唯一性来去掉重复的字段。还有一些系统提供的方法，还有谓词搜索筛选。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">- (void)findRepeatNum:(NSMutableArray *)arr &#123;</span><br><span class="line">    NSMutableArray *myArr = [NSMutableArray array];</span><br><span class="line">    for (int i = 0; i &lt; arr.count; i++) &#123;</span><br><span class="line">        BOOL isHave = NO;</span><br><span class="line">        for (int j = 0; j &lt; myArr.count; j++) &#123;</span><br><span class="line">            if ([arr[i] intValue] == [myArr[j] intValue]) &#123;</span><br><span class="line">                isHave = YES;</span><br><span class="line">                break;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                isHave = NO;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (!isHave) &#123;</span><br><span class="line">            [myArr addObject:arr[i]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>9、二分法查找<br>二分只适用于有序的数组查找<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">- (NSInteger)binarySearch:(NSArray *)array target:(NSInteger)target &#123;</span><br><span class="line">    if (array.count == 0) &#123;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    NSInteger start = 0;</span><br><span class="line">    NSInteger end = array.count - 1;</span><br><span class="line">    NSInteger mid = 0;</span><br><span class="line">    while (start + 1 &lt; end) &#123;</span><br><span class="line">        mid = start + (end - start) / 2;</span><br><span class="line">        if ([array[mid] integerValue] == target) &#123;</span><br><span class="line">            return mid;</span><br><span class="line">        &#125; else if ([array[mid] integerValue] &lt; target) &#123;</span><br><span class="line">            start = mid;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            end = mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if ([array[start] integerValue] == target) &#123;</span><br><span class="line">        return start;</span><br><span class="line">    &#125;</span><br><span class="line">    if ([array[end] integerValue] == target) &#123;</span><br><span class="line">        return end;</span><br><span class="line">    &#125;</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>10、求最大值和最小值，这个太简单了。。。<br>第一个为最大值或最小值，一个for循环比下去。</p><p>11、二叉树遍历<br>先序遍历-中左右<br>中序遍历-左中右<br>后续遍历-左右中</p><p>算法的我就先整理几个，后续会新增一些面试过程遇到的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近面试，被虐的很惨，实话实说，日常开发的东西基本上都会，有些不会的直接在stackoverflow上随便找找基本上都可以解决问题。面试的时候很多都是基础，平时遇见问题，google一下就带过了，也不会特意的背代码，很多问题都是碰见过，能解决，具体过程是真的忘了。所以有了以下这篇文章，想来一篇算法的，在来一份基础面试题，再之后写一篇面试的小问题吧。还有有一些答案不是最好的如果您有更好的，请给我留言，大家一起进步。—–来自一个非计算机专业的小白整理，请勿嘲笑。&lt;/p&gt;
    
    </summary>
    
    
      <category term="-iOS进阶" scheme="http://lvjunxue.com/tags/iOS%E8%BF%9B%E9%98%B6/"/>
    
  </entry>
  
  <entry>
    <title>ReactNative</title>
    <link href="http://lvjunxue.com/2017/09/10/ReactNative/"/>
    <id>http://lvjunxue.com/2017/09/10/ReactNative/</id>
    <published>2017-09-10T11:27:11.000Z</published>
    <updated>2018-10-10T06:43:24.485Z</updated>
    
    <content type="html"><![CDATA[<p>ReactNative内容。此文只献给那些没用过，还在排坑的小伙伴们。有错误内容还请指出。</p><a id="more"></a><p><a href="https://reactnative.cn/docs/integration-with-existing-apps/" target="_blank" rel="noopener">集成到现有原生应用</a>如过你还没有安装过或者没使用过，去中文网查看相关流程。</p><p>pod文件内加入基本的配置<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">pod 'React', :path =&gt; './RNComponent/node_modules/react-native', :subspecs =&gt; [</span><br><span class="line">    'Core',</span><br><span class="line">    'CxxBridge', # 如果RN版本 &gt;= 0.47则加入此行</span><br><span class="line">    'DevSupport', # 如果RN版本 &gt;= 0.43，则需要加入此行才能开启开发者菜单</span><br><span class="line">    'RCTText',</span><br><span class="line">    'RCTNetwork',</span><br><span class="line">    'RCTWebSocket', # 调试功能需要此模块</span><br><span class="line">    'RCTAnimation', # FlatList和原生动画功能需要此模块</span><br><span class="line">    <span class="meta">#在这里继续添加你所需要的其他RN模块</span></span><br><span class="line">]</span><br><span class="line"><span class="meta">#如果你的RN版本 &gt;= 0.42.0，则加入下面这行</span></span><br><span class="line">pod 'yoga', :path =&gt; './RNComponent/node_modules/react-native/ReactCommon/yoga'</span><br><span class="line"></span><br><span class="line"><span class="meta">#如果RN版本 &gt;= 0.45则加入下面三个第三方编译依赖</span></span><br><span class="line">pod 'DoubleConversion', :podspec =&gt; './RNComponent/node_modules/react-native/third-party-podspecs/DoubleConversion.podspec'</span><br><span class="line">pod 'glog', :podspec =&gt; './RNComponent/node_modules/react-native/third-party-podspecs/glog.podspec'</span><br><span class="line">pod 'Folly', :podspec =&gt; './RNComponent/node_modules/react-native/third-party-podspecs/Folly.podspec'</span><br></pre></td></tr></table></figure></p><p>具体内容我就不说了。记录下我的错误问题。</p><p>version0.57.1版本的时候出现问题记录：<br>[!] CocoaPods could not find compatible versions for pod “Folly”:<br>In Podfile:<br>Folly (from <code>./RNComponent/node_modules/react-native/third-party-podspecs/Folly.podspec</code>)</p><p>Specs satisfying the <code>Folly (from</code>./RNComponent/node_modules/react-native/third-party-podspecs/Folly.podspec<code>)</code> dependency were found, but they required a higher minimum deployment target.</p><p>三个第三方编译依赖Folly需要9.0以上：<br>修改platform :ios,’9.0’<br>they required a higher minimum deployment target.这句话提示怎么做。</p><p>如果你使用MLeaksFinder间接导入FBRetainCycleDetector。运行app会报错<br>Array has incomplete element type ‘struct rcd_rebinding’</p><p>原因是RN和FBRetainCycleDetector里都有<br>fishhook.c<br>fishhook.h<br>把FBRetainCycleDetector里的修改成<br>rcd_fishhook.c<br>rcd_fishhook.h<br>或者，坐等facebook更新喽。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;ReactNative内容。此文只献给那些没用过，还在排坑的小伙伴们。有错误内容还请指出。&lt;/p&gt;
    
    </summary>
    
    
      <category term="-iOS进阶" scheme="http://lvjunxue.com/tags/iOS%E8%BF%9B%E9%98%B6/"/>
    
  </entry>
  
  <entry>
    <title>ijkplayer</title>
    <link href="http://lvjunxue.com/2017/09/10/ijkplayer/"/>
    <id>http://lvjunxue.com/2017/09/10/ijkplayer/</id>
    <published>2017-09-10T11:27:11.000Z</published>
    <updated>2018-09-10T15:44:31.596Z</updated>
    
    <content type="html"><![CDATA[<p>生活不易啊，继续学习啊ijkplayer。</p><a id="more"></a><p><a href="https://github.com/Bilibili/ijkplayer" target="_blank" rel="noopener">B站GitHub</a>，先下载个ijkplayer吧。</p><p>默认为最少支持, 如果足够你使用, 可以跳过这一步. 否则可以改为以下配置:<br>module-default.sh 更多的编解码器/格式<br>module-lite-hevc.sh 较少的编解码器/格式(包括hevc)<br>module-lite.sh 较少的编解码器/格式(默认情况)</p><p>进入 config 目录<br>cd config<br>删除当前的 module.sh 文件<br>rm module.sh<br>可根据需要替换为<code>module-default.sh</code>, <code>module-lite-hevc.sh</code>, <code>module-lite.sh</code><br>创建软链接 module.sh 指向 module-lite-hevc.sh<br>ln -s module-lite-hevc.sh module.sh</p><p>em…编译，过程需要下载ffmpeg，毕竟基于ffmpeg嘛。打开终端，cd到ijkplayer-master，执行 ./init-ios.sh 时间可能会有点长。</p><p>支持https设置<br>获取 openssl 并初始化<br>./init-ios-openssl.sh</p><p>启用 openssl 组件方法<br>echo ‘export COMMON_FF_CFG_FLAGS=”$COMMON_FF_CFG_FLAGS –enable-openssl”‘ &gt;&gt; ../config/module.sh<br>或者<br>vim ../config/module.sh<br>export COMMON_FF_CFG_FLAGS=”$COMMON_FF_CFG_FLAGS –enable-openssl”</p><p>cd ios<br>./compile-ffmpeg.sh clean<br>./compile-openssl.sh all<br>过程是屏幕一顿飞，会出现警告，别慌！！！<br>如果不需要https以上步骤可以省略掉。</p><p>执行 ./compile-ffmpeg.sh all 中间可能会卡顿一下，然后一顿滚屏，别停止了喔。</p><p>./libavutil/arm/asm.S:50:9: error: unknown directive<br>.arch armv7-a<br>^</p><p>如果出这个错误。在 compile-ffmpeg.sh 中删除 armv7<br>FF_ALL_ARCHS_IOS8_SDK=”arm64 i386 x86_64”<br>再重新执行: ./compile-ffmpeg.sh all</p><p>然后运行IJKMediaDemo。把libcrypto.a和libssl.a加进去。</p><p>应该就可以使用了。只能看看在线的给你们一个地址试试吧，<a href="http://clips.vorwaerts-gmbh.de/big_buck_bunny.mp4" target="_blank" rel="noopener">http://clips.vorwaerts-gmbh.de/big_buck_bunny.mp4</a></p><p><a href="https://gcs-vimeo.akamaized.net/exp=1536608263~acl=%2A%2F623685558.mp4%2A~hmac=ac4bea3eee7fd318322ce65b675f742017a84c294aa0ac57f8480aa9bfd80037/vimeo-prod-skyfire-std-us/01/2670/7/188350983/623685558.mp4" target="_blank" rel="noopener">https://gcs-vimeo.akamaized.net/exp=1536608263~acl=%2A%2F623685558.mp4%2A~hmac=ac4bea3eee7fd318322ce65b675f742017a84c294aa0ac57f8480aa9bfd80037/vimeo-prod-skyfire-std-us/01/2670/7/188350983/623685558.mp4</a></p><p>打包 framwork完成最后的工作！！！<br>open IJKMediaPlayer/IJKMediaPlayer.xcodeproj</p><p>配置 Release 模式<br>打包真机 framework<br>如果之前删除了armv7，注释include “armv7/avconfig.h”<br>command+b<br>打包模拟器 framework<br>command+b<br>在Products里有IJKMediaFramework.framework，右键，show in Finder</p><p>合并 framework</p><p>cd 到 Products目录下lipo -create 真机framework路径 模拟器framework路径 -output 合并的文件路径</p><p>lipo -create Release-iphoneos/IJKMediaFramework.framework/IJKMediaFramework Release-iphonesimulator/IJKMediaFramework.framework/IJKMediaFramework -output IJKMediaFramework</p><p>生成了IJKMediaFramework文件，拖入真机或模拟器的framework中，替换掉之前的IJKMediaFramework，之后IJKMediaFramework.framework可以导入工程了。</p><p>添加下列依赖到工程<br>libc++.tbd<br>libz.tbd<br>libbz2.tbd<br>AudioToolbox.framework<br>UIKit.framework<br>CoreGraphics.framework<br>AVFoundation.framework<br>CoreMedia.framework<br>CoreVideo.framework<br>MediaPlayer.framework<br>MobileCoreServices.framework<br>OpenGLES.framework<br>QuartzCore.framework<br>VideoToolbox.framework</p><p>在Header Search Paths加入头文件的路径。</p><p>另外如果要支持rtsp<br>在 ijkplayer-master 下的 config 中，打开 module-lite.sh<br>将 export COMMON_FF_CFG_FLAGS=”$COMMON_FF_CFG_FLAGS –disable-protocol=rtp”<br>修改为 export COMMON_FF_CFG_FLAGS=”$COMMON_FF_CFG_FLAGS –enable-protocol=rtp”<br>并添加 export COMMON_FF_CFG_FLAGS=”$COMMON_FF_CFG_FLAGS –enable-demuxer=rtsp”<br>export COMMON_FF_CFG_FLAGS=”$COMMON_FF_CFG_FLAGS –enable-decoder=mjpeg”<br>export COMMON_FF_CFG_FLAGS=”$COMMON_FF_CFG_FLAGS –enable-demuxer=mjpeg”<br>然后命令行执行:<br>rm module.sh<br>ln -s module-lite.sh module.sh<br>在执行cd到ios那步。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;生活不易啊，继续学习啊ijkplayer。&lt;/p&gt;
    
    </summary>
    
    
      <category term="-iOS进阶" scheme="http://lvjunxue.com/tags/iOS%E8%BF%9B%E9%98%B6/"/>
    
  </entry>
  
  <entry>
    <title>Cocoa Touch</title>
    <link href="http://lvjunxue.com/2017/08/20/Cocoa%20Touch/"/>
    <id>http://lvjunxue.com/2017/08/20/Cocoa Touch/</id>
    <published>2017-08-20T13:34:27.000Z</published>
    <updated>2018-08-21T03:41:13.657Z</updated>
    
    <content type="html"><![CDATA[<p>Cocoa Touch就是指Foundation框架和UIKit框架。</p><a id="more"></a><p>系统最上层的，编写代码的时候，先看看这层提供的技术是否能满足你的需求，如果能，就用。不行在往下层去搞。</p><p>Cocoa Touch都有啥</p><p>Message UI<br>提供了App集成邮件与短信的支持。支持包括在App界面中弹出一个视图控制器界面。可以在该视图控制器中填入接收者，主题，主要内容和任意你想包含在信息里的附件。在弹出该视图控制器后，用户可以选择在发送之前对其做出编辑。</p><p>Address Book UI<br>一个Object-C编程接口，用来显示创建新联系人和编辑已经存在联系人信息的标准系统联系人界面。该框架简化了在App中显示联系人信息的操作，同时保证所有App的联系人界面在同一平台上都相同。</p><p>EventKit UI<br>提供了可以弹出查看和编辑日程相关事件的标准系统界面的视图控制器。该框架建立在EventKit框架的事件相关数据之上。</p><p>GameKit<br>实现了对Game Centre的支持，Game Center让用户可以在线分享游戏相关数据。</p><p>iAd<br>让App实现横幅广告的展示。广告会嵌入到你的交互界面的标准视图中，并在需要的时候弹出。</p><p>MapKit<br>提供可嵌入到App的用户界面中的可拖拽地图。可以使用该框架来自定义地图的内容与外观。</p><p>NotificationCenter<br>提供创建在通知中心里显示信息的小部件的功能。</p><p>PushKit<br>提供VoIP App的注册使用支持。该框架替代了之前注册VoIP App的API。</p><p>UIKit<br>提供了实现绘图和事件驱动App的重要基础。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Cocoa Touch就是指Foundation框架和UIKit框架。&lt;/p&gt;
    
    </summary>
    
    
      <category term="-iOS进阶" scheme="http://lvjunxue.com/tags/iOS%E8%BF%9B%E9%98%B6/"/>
    
  </entry>
  
  <entry>
    <title>离屏渲染问题</title>
    <link href="http://lvjunxue.com/2017/04/02/GPU%E7%A6%BB%E5%B1%8F%E6%B8%B2%E6%9F%93/"/>
    <id>http://lvjunxue.com/2017/04/02/GPU离屏渲染/</id>
    <published>2017-04-02T11:04:18.000Z</published>
    <updated>2018-08-16T06:23:38.534Z</updated>
    
    <content type="html"><![CDATA[<p>这个是我没事的时候在Stackoverflow瞎溜达时候看的</p><a id="more"></a><p>什么是离屏渲染？</p><p>GPU了解下？</p><p>OpenGL的中，GPU屏幕渲染有两种方式。<br>屏幕渲染（当前屏幕渲染）指的是GPU的渲染操作是在当前用于显示的屏幕缓冲区进行。<br>离屏渲染（离屏渲染）指的是在GPU在当前屏幕缓冲区以外开辟一个缓冲区进行渲染操作。<br>当发生离屏的时候，可能导致FPS下降，说白了，卡顿。人眼的辨识是30+</p><p>什么时候会发生离屏渲染</p><p>光栅化、遮罩、阴影、抗锯齿、不透明、复杂形状设置圆角等等，所以新建的空间如果能透明就透明。</p><p>怎么检测呢？<br>Instruments的Core Animation工具中有几个和离屏渲染相关的检查选项：<br>Color Offscreen-Rendered Yellow<br>开启后会把那些需要离屏渲染的图层高亮成黄色，这就意味着黄色图层可能存在性能问题。<br>Color Hits Green and Misses Red</p><p>更新下，改版了新的Xcode<br>（Debug）-（View Debugging）-（Rendering）-（Color Offscreen-Rendered Yellow）</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这个是我没事的时候在Stackoverflow瞎溜达时候看的&lt;/p&gt;
    
    </summary>
    
    
      <category term="-iOS进阶" scheme="http://lvjunxue.com/tags/iOS%E8%BF%9B%E9%98%B6/"/>
    
  </entry>
  
  <entry>
    <title>捕获Crash</title>
    <link href="http://lvjunxue.com/2017/03/09/Crash%E6%94%B6%E9%9B%86/"/>
    <id>http://lvjunxue.com/2017/03/09/Crash收集/</id>
    <published>2017-03-09T04:00:12.000Z</published>
    <updated>2018-09-05T23:46:00.736Z</updated>
    
    <content type="html"><![CDATA[<p>新需求～捕获Crash，虽然我每次提交代码之后都会说没BUG，测试吧。。。处女座，不能说没有，很少吧。</p><a id="more"></a><p>iTunes Connect的App分析中有，但是需要用户来设置，所以呢，没啥大用！！！</p><p>很多第三方也可以做，比如友盟移动统计，Mob移动统计，百度移动统计等等。</p><p>如果你想自己实现呢？</p><p>我给你俩工具，具体如何来做。。。那就看你学不学习了</p><p>DSYMTools分析工具,和邮件发送SKPSMTPMessage。</p><p>兄die，加油了。</p><p>Plcrashreporter听说这个很多大公司在用。了解下。。。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;新需求～捕获Crash，虽然我每次提交代码之后都会说没BUG，测试吧。。。处女座，不能说没有，很少吧。&lt;/p&gt;
    
    </summary>
    
    
      <category term="-iOS进阶" scheme="http://lvjunxue.com/tags/iOS%E8%BF%9B%E9%98%B6/"/>
    
  </entry>
  
  <entry>
    <title>hexo图片放置七牛云</title>
    <link href="http://lvjunxue.com/2017/03/06/hexo%E5%9B%BE%E7%89%87%E6%94%BE%E7%BD%AE%E4%B8%83%E7%89%9B%E4%BA%91/"/>
    <id>http://lvjunxue.com/2017/03/06/hexo图片放置七牛云/</id>
    <published>2017-03-06T03:44:25.000Z</published>
    <updated>2018-08-16T05:09:18.411Z</updated>
    
    <content type="html"><![CDATA[<p>其实这是一个测试我配置完的博文，七牛放置图片很简单，百度一下就很多了。</p><a id="more"></a><p><img src="http://p55cuazcg.bkt.clouddn.com/6.jpg" alt="image"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;其实这是一个测试我配置完的博文，七牛放置图片很简单，百度一下就很多了。&lt;/p&gt;
    
    </summary>
    
    
      <category term="-hexo记录" scheme="http://lvjunxue.com/tags/hexo%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>组件化</title>
    <link href="http://lvjunxue.com/2017/03/03/iOS%E7%BB%84%E4%BB%B6%E5%8C%96/"/>
    <id>http://lvjunxue.com/2017/03/03/iOS组件化/</id>
    <published>2017-03-03T09:00:12.000Z</published>
    <updated>2018-08-16T05:56:15.826Z</updated>
    
    <content type="html"><![CDATA[<p>封装、封装再封装。如果你是单人开发，这么高耦合的代码会加速你的开发。但是，有时候业务逻辑有所改变，你会把项目改的很乱</p><a id="more"></a><p>Url-Block、Protocol-Class(Url-Controller)、Target-Action</p><p>思路都是走一个路由（中间件）来完成页面之间的传递信息。</p><p>网上的已经满天的文章了，具体内容我就不多说了。</p><p>我说一下一个项目是否该用组件化，怎么选择。</p><p>如果你是单人开发，公司的项目设计的业务不是特别多，你可以不考虑组件化，毕竟单人开发的时候有很多地方个人感觉完全没必要，只要不写很多高度耦合的代码出来一个MVVM可以应对项目。</p><p>如果不是单人开发，项目中设计的业务也比较广泛，还有公司可以会有多个业务，很多内容的功能都是类似的，可以考虑用组建来做。毕竟很多基础组建写好之后，可以在很多项目中重用。</p><p>至于选择，其实每个都有自己的优劣，不要被选择困惑。我个人比较喜欢Target-Action多一点。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;封装、封装再封装。如果你是单人开发，这么高耦合的代码会加速你的开发。但是，有时候业务逻辑有所改变，你会把项目改的很乱&lt;/p&gt;
    
    </summary>
    
    
      <category term="-iOS进阶" scheme="http://lvjunxue.com/tags/iOS%E8%BF%9B%E9%98%B6/"/>
    
  </entry>
  
  <entry>
    <title>无痕埋点</title>
    <link href="http://lvjunxue.com/2017/02/03/iOS%E6%97%A0%E7%97%95%E5%9F%8B%E7%82%B9/"/>
    <id>http://lvjunxue.com/2017/02/03/iOS无痕埋点/</id>
    <published>2017-02-03T08:08:49.000Z</published>
    <updated>2018-08-16T05:37:19.721Z</updated>
    
    <content type="html"><![CDATA[<p>以前都是手动来埋，有时候会忘记，研究了下无痕埋点，省掉了很多东西</p><a id="more"></a><p>Google了很多文章，发现都是面向切面的AOP思想来做的，总结起来就是偷梁换柱的Runtime黑魔法。</p><p>先来一大推的分类。来来来，统一替换埋点的方法。部分点击的分类要考虑深一点，比如UIButton使用UIControl会比较好，UIControl还包含了其他的一些控件。</p><p>那我怎么知道是哪个页面？</p><p>来个plist文件对应表～</p><ul><li><p>(NSString <em>)pageEventID:(BOOL)enterPage<br>{<br>  NSDictionary </em>configDict = [self dictionaryFromUserStatisticsConfigPlist];<br>  NSString *selfClassName = NSStringFromClass([self class]);<br>  return configDict[selfClassName][@”PageEventIDs”][enterPage ? @”Enter” : @”Leave”];<br>}</p></li><li><p>(NSDictionary <em>)dictionaryFromUserStatisticsConfigPlist<br>{<br>  NSString </em>filePath = [[NSBundle mainBundle] pathForResource:@”Config” ofType:@”plist”];<br>  NSDictionary *dic = [NSDictionary dictionaryWithContentsOfFile:filePath];<br>  return dic;<br>}</p></li></ul><p>可能是记录blog，所以写的比较粗糙。</p><p>还有埋点的时候要善于使用XCTAssert。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;以前都是手动来埋，有时候会忘记，研究了下无痕埋点，省掉了很多东西&lt;/p&gt;
    
    </summary>
    
    
      <category term="-iOS进阶" scheme="http://lvjunxue.com/tags/iOS%E8%BF%9B%E9%98%B6/"/>
    
  </entry>
  
  <entry>
    <title>WebRTC</title>
    <link href="http://lvjunxue.com/2017/01/05/WebRTC/"/>
    <id>http://lvjunxue.com/2017/01/05/WebRTC/</id>
    <published>2017-01-05T05:09:33.000Z</published>
    <updated>2018-08-29T02:20:53.483Z</updated>
    
    <content type="html"><![CDATA[<p>WebRTC内容，简单集成。</p><a id="more"></a><p>搞个环境吧。。。</p><p><a href="http://www.cnblogs.com/fulianga/p/5868823.html下载编译" target="_blank" rel="noopener">http://www.cnblogs.com/fulianga/p/5868823.html下载编译</a><br>如果你要试试功能，去gitHub上随便找一个版本就行了。</p><p>一个头文件的文件夹，加一个.a文件。</p><p>导入系统依赖库<br>CoreMedia.framework<br>AVFoundation.framework<br>AudioToolbox.framework<br>GLKit.framework<br>OpenGLES.framework<br>VideoToolbox.framework<br>libicucore.tbd<br>libstdc++.6.tbd<br>libc++.tbd<br>libresolv.tbd<br>libxml2.tbd<br>OK环境完事了。</p><p>WebRTC主要实现了三个API，分别是:<br>MediaStream：通过MediaStream的API能够通过设备的摄像头及话筒获得视频、音频的同步流。<br>RTCPeerConnection：RTCPeerConnection是WebRTC用于构建点对点之间稳定、高效的流传输的组件。<br>RTCDataChannel：RTCDataChannel使得浏览器之间（点对点）建立一个高吞吐量、低延时的信道，用于传输任意数据。<br>其中RTCPeerConnection是我们WebRTC的核心组件。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">WebRTCHelperDelegate</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">WebRTCHelper</span> : <span class="title">NSObject</span>&lt;<span class="title">SRWebSocketDelegate</span>&gt;</span></span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">instancetype</span>)sharedInstance;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>)<span class="keyword">id</span>&lt;WebRTCHelperDelegate&gt; delegate;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*  与服务器建立连接</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*  @param server 服务器地址</span></span><br><span class="line"><span class="comment">*  @param room   房间号</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">- (<span class="keyword">void</span>)connectServer:(<span class="built_in">NSString</span> *)server port:(<span class="built_in">NSString</span> *)port room:(<span class="built_in">NSString</span> *)room;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*  退出房间</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">- (<span class="keyword">void</span>)exitRoom;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">WebRTCHelperDelegate</span> &lt;<span class="title">NSObject</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@optional</span></span><br><span class="line">- (<span class="keyword">void</span>)webRTCHelper:(WebRTCHelper *)webRTChelper setLocalStream:(RTCMediaStream *)stream userId:(<span class="built_in">NSString</span> *)userId;</span><br><span class="line">- (<span class="keyword">void</span>)webRTCHelper:(WebRTCHelper *)webRTChelper addRemoteStream:(RTCMediaStream *)stream userId:(<span class="built_in">NSString</span> *)userId;</span><br><span class="line">- (<span class="keyword">void</span>)webRTCHelper:(WebRTCHelper *)webRTChelper closeWithUserId:(<span class="built_in">NSString</span> *)userId;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>把所有的头文件都看一圈。。。em。。。反正没人看，我就是自己记录一下而已。</p><p>具体实现过程的文章。</p><p><a href="https://www.jianshu.com/p/c49da1d93df4" target="_blank" rel="noopener">iOS下音视频通信-基于WebRTC</a><br>还有一些即时通讯的文章，统一在这记录一下。。。<br><a href="https://www.jianshu.com/p/2dbb360886a8" target="_blank" rel="noopener">iOS即时通讯，从入门到“放弃”？</a><br><a href="https://www.jianshu.com/p/0a11b2d0f4ae" target="_blank" rel="noopener">iOS即时通讯进阶 - CocoaAsyncSocket源码解析(Connect篇)</a><br><a href="https://www.jianshu.com/p/22c984eac9b9" target="_blank" rel="noopener">iOS即时通讯进阶 - CocoaAsyncSocket源码解析(Connect篇终)</a><br><a href="https://www.jianshu.com/p/fdd3d429bdb3" target="_blank" rel="noopener">iOS即时通讯进阶 - CocoaAsyncSocket源码解析(Read篇)</a><br><a href="https://www.jianshu.com/p/19f0fd363f60" target="_blank" rel="noopener">iOS即时通讯进阶 - CocoaAsyncSocket源码解析(Read篇终)</a></p><p>上面的作者很用心，写了很多，多读读，其实简单实现还是很容易的。但是！！！你要知道你的Demo只面对了你自己，当你面对9亿网民的时候，有可能分分钟就被干趴了，还是要好好研究才能上项目的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;WebRTC内容，简单集成。&lt;/p&gt;
    
    </summary>
    
    
      <category term="-iOS进阶" scheme="http://lvjunxue.com/tags/iOS%E8%BF%9B%E9%98%B6/"/>
    
  </entry>
  
  <entry>
    <title>视频直播</title>
    <link href="http://lvjunxue.com/2017/01/03/iOS%E8%A7%86%E9%A2%91%E7%9B%B4%E6%92%AD/"/>
    <id>http://lvjunxue.com/2017/01/03/iOS视频直播/</id>
    <published>2017-01-03T11:05:44.000Z</published>
    <updated>2018-08-29T01:58:08.291Z</updated>
    
    <content type="html"><![CDATA[<p>现在第三方集成视频直播的有很多了，想完成一个其实一顿SDK很无脑的就能搞出一个APP。</p><a id="more"></a><p>鉴于对程序的热爱（必不得已）仔细的研究了整个视频直播的过程，具体实现没有做，很多大咖写的非常好了，写这篇播客的目的就是, 想记录一下当时的思路。</p><p>主播端：<br>1）需要做的音视频采集<br>2）视频处理、美颜滤镜之类的（毕竟主播要美美哒）<br>3）视频编码。<br>4）推流到服务器（RTMP,HLS,FLV）</p><p>用户端：<br>1）拉流。<br>2）解码。<br>3）观看。</p><p>用什么来做？em。。。<br>B站的ijkPlayer听过没。如果没有，那ffmpeg了解下。</p><p>在说一下其他的东西，如果真的想在图像视频方面深挖，学学OpenGL（ES）其实不错的。</p><p>WebRTC内容，之后在写吧。。。。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;现在第三方集成视频直播的有很多了，想完成一个其实一顿SDK很无脑的就能搞出一个APP。&lt;/p&gt;
    
    </summary>
    
    
      <category term="-iOS进阶" scheme="http://lvjunxue.com/tags/iOS%E8%BF%9B%E9%98%B6/"/>
    
  </entry>
  
  <entry>
    <title>远程Git仓库</title>
    <link href="http://lvjunxue.com/2016/08/10/%E8%BF%9C%E7%A8%8BGit%E4%BB%93%E5%BA%93/"/>
    <id>http://lvjunxue.com/2016/08/10/远程Git仓库/</id>
    <published>2016-08-10T11:05:44.000Z</published>
    <updated>2020-08-24T08:12:27.744Z</updated>
    
    <content type="html"><![CDATA[<p>脑子不好用了，总是忘记点啥，还是备注下吧</p><a id="more"></a><p>开始～～～～～～</p><p>远程私有仓库（分支仓库）</p><p>pod repo    看看有没有自己的！</p><p>pod repo add 私有库名字 你的私有库地址</p><p>pod lib create XXX                  然后一顿选择。</p><p>cd到目录下</p><p>添加git远程私有库关联    git remote查看，应该是没有的，如果你不相信就自己看下咯。</p><p>git remote add origin XXX</p><p>修改podspec文件<br>s.summary 、s.homepage、s.source、s.source_files等等，自行百度。<br>分支内容来了！！！！<br>s.source_files注释掉<br>s.subspec ‘XXX’ do |X|<br>    X.source_files = ‘路径’<br>    X.dependency = ‘其他库’<br>end</p><p>提交去远程仓库<br>$ git add .</p><ul><li>git add -A  提交所有变化</li><li>git add -u  提交被修改(modified)和被删除(deleted)文件，不包括新文件(new)</li><li>git add .  提交新文件(new)和被修改(modified)文件，不包括被删除(deleted)文件</li></ul><p>$ git status    看看是不是都变绿了</p><p>$ git commit -m “message”<br>阿哥in<br>上传代码<br>$ git push origin master</p><p>强制提交 git push -u origin master -f</p><p>打标签，并且把标签提交到远程私地址$ git tag<br>$ git tag -a ‘0.0.4’ -m “首次测试完成版”<br>上传标签    $ git push –tags</p><p>验证spec并提交到本地私有索引库<br>验证本地 $ pod lib lint<br>验证远程 $ pod spec lint</p><p>首次提交时候，发现–no-clean的错误，可能是因为没有版本的问题，–allow-warnings</p><p>使用framework时，后面添加–use-libraries<br>有忽略警告时，后天添加–no-clean</p><p>都通过后提交本地<br>$ pod repo push XXX XXX.podspec</p><p>使用的时候   soure’adress’</p><p>pod ‘spec’<br>pod ‘spec/xxx’<br>pod ‘spec’, :subspecs =&gt; [‘xxx’, ‘xxx’]</p><p>验证spec的时候如果你引用了私有的库    在验证后面加上–sources=地址,master     更多内容查看help</p><p>clang -x objective-c -rewrite-objc -isysroot /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk</p><p>git branch    //当前本地分支列表<br>git branch -r       //当前库分支列表</p><p>git checkout develop   //checkout下 想合并的分支<br>git merge AdHub-Cookie      //将分支merge到当前分支下<br>git add .       //提交<br>git push        //推送上去</p><p>git branch -d AdHub-Cookie      //删除本地分支<br>git push origin –delete AdHub-Cookie       //删除远程分支</p><p>还是可以看到已删除的远程分支，时间一长就显的非常乱了<br>以下是解决方法：<br>git remote show origin //可以看到删除分支情况<br>git remote prune origin<br>再执行<br>git branch -a</p><p>在某个分支下拉取代码<br>git checkout -b Feature-Networking<br>git push origin Feature-Networking</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;脑子不好用了，总是忘记点啥，还是备注下吧&lt;/p&gt;
    
    </summary>
    
    
      <category term="-环境搭建" scheme="http://lvjunxue.com/tags/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    
  </entry>
  
</feed>
