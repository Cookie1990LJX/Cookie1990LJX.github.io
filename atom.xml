<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Cookie&#39;s Blog</title>
  
  <subtitle>信念、追求、超越</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://lvjunxue.com/"/>
  <updated>2018-10-11T05:09:56.941Z</updated>
  <id>http://lvjunxue.com/</id>
  
  <author>
    <name>Cookie</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>iOS基础</title>
    <link href="http://lvjunxue.com/2018/10/11/iOS%E5%9F%BA%E7%A1%80/"/>
    <id>http://lvjunxue.com/2018/10/11/iOS基础/</id>
    <published>2018-10-11T01:56:18.000Z</published>
    <updated>2018-10-11T05:09:56.941Z</updated>
    
    <content type="html"><![CDATA[<p>接上一个篇，iOS基础。以下答案均为自己想法，有一些答案没有往深处去挖，如有错误跪求指出。</p><p><font color="#0099ff"></font><br><a id="more"></a><br>给你瞅瞅什么是开局一刀，后面把你砍成渣！！！</p><p><font color="#0099ff">@property的本质是什么？</font></p><p><table><tr><td bgcolor="#808080"><br>实例变量+get方法+set方法,也就是说使用@property系统会自动生成setter和getter方法。<br></td></tr></table></p><p><font color="#0099ff">@property 后面可以有哪些修饰符？</font><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nonatomic，atomic，strong，copy，retain，weak，assign，readonly，writeonly，readwrite。</span><br></pre></td></tr></table></figure></p><p>接下来问题来了，<font color="#0099ff">strong和copy的区别？</font>问完还可以问<font color="#0099ff">copy和mutablecopy区别？</font><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">源头不可变的strong和copy没区别，都是浅拷贝。源头可变的strong是浅，copy是深。其实这个很好记copy思想就是不能变。至于mutablecopy就是深，我可不管你能不能变。如果你还是不明白，你最好写一个小Demo去深入的看看结果。</span><br></pre></td></tr></table></figure></p><p><font color="#0099ff">如何让自己的类用 copy 修饰符？如何重写带 copy 关键字的 setter？</font><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">需声明该类遵从 NSCopying 协议</span><br><span class="line">实现 NSCopying 协议的方法。该协议只有一个方法:- (id)copyWithZone:(NSZone *)zone;</span><br></pre></td></tr></table></figure></p><p><font color="#0099ff">weak和assign的区别？</font><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">weak修饰的变量无野指针，释放的同时置空，访问不会crash。但只能修饰OC的对象。</span><br><span class="line">assign可以用于非OC对象。</span><br></pre></td></tr></table></figure></p><p>这个之后又是延伸问题<font color="#0099ff">weak是如何置空的？</font><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">runtime 对于 weak 对象会放入一个 hash 表中。 用 weak 指向的对象内存地址作为 key，当此对象的引用计数为0的时候会 dealloc，runtime调用clearDeallocating函数，假如 weak 指向的对象内存地址是a，那么就会以a为键， 在这个 weak 表中搜索，找到所有以a为键的 weak 对象，从而设置为 nil。</span><br></pre></td></tr></table></figure></p><p><font color="#0099ff">nonatomic和atomic的区别？</font><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">在声明的时候如果不写，那么默认是atomic。</span><br><span class="line">atomic线程安全，速度慢。系统生成的 getter/setter 会保证 get、set 操作的完整性，不受其他线程影响。比如，线程 A 的 getter 方法运行到一半，线程 B 调用了 setter：那么线程 A 的 getter 还是能得到一个完好无损的对象。如果多个线程同时操作 get、set 方法，最后 get 得到的值有多种可能。</span><br><span class="line">nonatomic线程不安全，速度快。如有两个线程访问同一个属性，会出现无法预料的结果</span><br></pre></td></tr></table></figure></p><p>这些问好了还有其他的关键字一并都能引申出来</p><p><font color="#0099ff"><strong>block和</strong>weak区别？</font><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1）block下循环引用的问题</span><br><span class="line">__block本身并不能避免循环引用，避免循环引用需要在 block 内部把 __block 修饰的obj置为nil</span><br><span class="line">__weak可以避免循环引用，但是其会导致外部对象释放了之后，block 内部也访问不到这个对象的问题，我们可以通过在 block 内部声明一个 __strong</span><br><span class="line">的变量来指向 weakObj，使外部对象既能在 block 内部保持住，又能避免循环引用的问题</span><br><span class="line">2）__block 与 __weak 功能上的区别。</span><br><span class="line">__block 会持有该对象，即使超出了该对象的作用域，该对象还是会存在的，直到 block 对象从堆上销毁；而__weak 仅仅是将该对象赋值给 weak 对象，当该对象销毁时，weak 对象将指向nil；</span><br><span class="line">__block 可以让 block 修改局部变量，而 __weak 不能。</span><br><span class="line">另外，MRC中 __block 是不会引起 retain；但在ARC中 __block 则会引起 retain。所以ARC中应该使用 __weak。</span><br></pre></td></tr></table></figure></p><p><font color="#0099ff">block本质是什么？</font><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">其实 Block 的本质是带有函数执行上下文环境的结构体，其中包含被调函数指针</span><br></pre></td></tr></table></figure></p><p><font color="#0099ff">block截获变量的特性应该怎样解释？</font><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__block 所起到的作用就是只要观察到该变量被 block 所持有，就将“外部变量”在栈中的内存地址放到了堆中</span><br></pre></td></tr></table></figure></p><p><font color="#0099ff">block和delegate区别？</font><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1）delegate 运行成本低，block 运行成本高。</span><br><span class="line">block 出栈需要将使用的数据从栈内存拷贝到堆内存，使用完或者 block 置 nil 后被消除。delegate 只是保存了一个对象的指针，直接回调，没有额外消耗。</span><br><span class="line">2）delegate 是 weak 弱引用；block 是 copy 修饰，强引用。delegate 更安全些，block 容易引起循环引用。</span><br><span class="line">3）block 直接访问上下文，块和块实现在同一个地方，代码组织更加连贯。</span><br><span class="line">delegate 声明和方法分离开来，代码的连贯性不是很好。</span><br></pre></td></tr></table></figure></p><p>有可能还会引出以下问题；</p><p><font color="#0099ff">block种类？</font><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">_NSConcreteGlobalBlock 全局的静态 block，不会访问外部局部变量。</span><br><span class="line">_NSConcreteMallocBlock 保存在堆中的 block，当引用计数为 0 时会被销毁。</span><br><span class="line">_NSConcreteStackBlock 保存在栈中的 block，当函数返回时会被销毁。</span><br></pre></td></tr></table></figure></p><p><font color="#0099ff">delegate和Notification的区别？</font><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">水平有限，我逛了一圈唯一发现的的就是1对1，1对多的不同，外加就是效率上 delegate 比较高，还有就是使用的时候看紧密程度，如果高就用 delegate 否则用 Notification，多线程里一般会用 Notification。</span><br></pre></td></tr></table></figure></p><p><font color="#0099ff">NSNotificationCenter的原理？</font><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NSNotificatinonCenter 是使用观察者模式来实现的用于跨层传递消息，用来降低耦合度。</span><br><span class="line">NSNotificatinonCenter 用来管理通知，将观察者注册到 NSNotificatinonCenter 的通知调度表中，然后发送通知时利用标识符 name 和 object 识别出调度表中的观察者，然后调用相应的观察者的方法，即传递消息（在Objective-C中对象调用方法，就是传递消息，消息有 name 或者 selector，可以接受参数，而且可能有返回值），如果是基于 block 创建的通知就调用 NSNotification 的 block。</span><br></pre></td></tr></table></figure></p><p><font color="#0099ff">Notification使用的时候要注意什么？</font><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Notification 使用的时候 add 和 remove 要成对的写。如果 add 之后没有 remove，那么你下次进来的时候，会通知2次。</span><br><span class="line">还有同名的注册多少次，他的执行代码就会执行多少次，但是移除的时候会一次性全部移除。</span><br></pre></td></tr></table></figure></p><p>很好提到了观察者模式，来吧继续下面的</p><p><font color="#0099ff">KVC和KVO？</font><br>这个牛逼的，你想解释起来，那真是长篇大论，能说好久。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">KVC 通过 Key 名直接访问对象的属性，或者给对象的属性赋值。</span><br><span class="line">日常使用的地方：动态地取值和设值，访问和修改私有变量，Model 和字典转换，修改一些控件的内部属性</span><br><span class="line"></span><br><span class="line">KVO 其基本思想是，对目标对象的某属性添加观察，当该属性发生变化时，通过触发观察者对象实现的 KVO 接口方法，来自动的通知观察者。</span><br><span class="line">日常使用的地方：你用MVVM嘛？</span><br></pre></td></tr></table></figure></p><p><font color="#0099ff">KVO原理？</font><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">KVO 是通过 isa-swizzling 实现的。</span><br><span class="line">基本的流程就是编译器自动为被观察对象创造一个派生类，并将被观察对象的 isa 指向这个派生类。如果用户注册了对某此目标对象的某一个属性的观察，那么此派生类会重写这个方法，并在其中添加进行通知的代码。Objective-C 在发送消息的时候，会通过 isa 指针找到当前对象所属的类对象。而类对象中保存着当前对象的实例方法，因此在向此对象发送消息时候，实际上是发送到了派生类对象的方法。由于编译器对派生类的方法进行了 override，并添加了通知代码，因此会向注册的对象发送通知。注意派生类只重写注册了观察者的属性方法。</span><br></pre></td></tr></table></figure></p><p>em？？？解释的迷迷糊糊一知半解，来来来咱们继续runtime走起！</p><p><font color="#0099ff">什么是runtime？</font><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">运行时，运行的时候决定具体要干什么</span><br></pre></td></tr></table></figure></p><p>嗯，字面意思，大家都知道，继续！！！</p><p><font color="#0099ff">你都在什么地方使用过runtime</font><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">分类添加属性，方法添加或替换。</span><br></pre></td></tr></table></figure></p><p><font color="#0099ff">runtime怎么添加属性、方法等</font><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class_addIvar，class_addMethod，class_addProperty，class_addProtocol，class_replaceProperty</span><br></pre></td></tr></table></figure></p><p><font color="#0099ff">runtime如何通过selector找到对应的IMP地址？</font><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">类对象中有类方法和实例方法的列表，列表中记录着方法的名词、参数和实现，而selector本质就是方法名称，runtime通过这个方法名称就可以在列表中找到该方法对应的实现。还有缓存机制别忘了。</span><br></pre></td></tr></table></figure></p><p>go on永不止步</p><p><font color="#0099ff">消息机制方法调用流程？</font><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">对象方法：(保存到类对象的方法列表) ，类方法：(保存到元类(Meta Class)中方法列表)。</span><br><span class="line">1）OC 在向一个对象发送消息时，runtime 库会根据对象的 isa 指针找到该对象对应的类或其父类中查找方法。</span><br><span class="line">2）注册方法编号（这里用方法编号的好处，可以快速查找）。</span><br><span class="line">3）根据方法编号去查找对应方法。</span><br><span class="line">4）找到只是最终函数实现地址，根据地址去方法区调用对应函数。</span><br></pre></td></tr></table></figure></p><p>一波未平一波又起</p><p><font color="#0099ff">消息转发？或者 _objc_msgForward 干什么的？</font><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">当向一个对象发送一条消息，但它并没有实现的时候，_objc_msgForward 会尝试做消息转发。消息转发的过程会调用几个方法</span><br><span class="line">1）resolveInstanceMethod 是否动态的添加一个方法，添加提前结束消息转发，否则，继续执行</span><br><span class="line">2）forwardingTargetForSelector 诶，兄弟有人能帮我实现不？转发给另一个对象有，提前结束，否则，继续执行</span><br><span class="line">3）调用 methodSignatureForSelector 获取方法签名后，判断返回类型信息是否正确，再调用 forwardInvocation 执行 NSInvocation 对象，并将结果返回。如果对象没实现 methodSignatureForSelector 方法，进入最后一步。</span><br><span class="line">4）doesNotRecognizeSelector 没人管！</span><br></pre></td></tr></table></figure></p><p>是不是感觉到什么了，嘿嘿嘿 runtime 完事了，是不是要 runloop 了，在然后估计就是多线程</p><p><font color="#0099ff">什么是 runloop ？</font><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p><p><font color="#0099ff">runloop的mode作用是什么？</font><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p><p><font color="#0099ff">什么地方使用过runloop？</font><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p><p>嗯这里可以引申出一个定时器的问题</p><p><font color="#0099ff">NSTimer使用时需要注意什么</font><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p><p><font color="#0099ff">runloop 和线程有什么关系？</font><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p><p><font color="#0099ff">GCD和NSOperationQueue的区别？</font><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p><p><font color="#0099ff">队列？</font><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p><p><font color="#0099ff">GCD中dispatch_barrier_async做什么的？</font><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p><p><font color="#0099ff">如何用GCD同步若干个异步调用？</font><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p><p>这块就进入了锁的知识</p><p><font color="#0099ff">如何使用队列来避免资源抢夺？</font><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p><p><font color="#0099ff">苹果为什么要废弃dispatch_get_current_queue？</font><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">容易造成死锁</span><br></pre></td></tr></table></figure></p><p>我要去面试了，回来继续写！！！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;接上一个篇，iOS基础。以下答案均为自己想法，有一些答案没有往深处去挖，如有错误跪求指出。&lt;/p&gt;
&lt;p&gt;&lt;font color=&quot;#0099ff&quot;&gt;&lt;/font&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="-iOS基础" scheme="http://lvjunxue.com/tags/iOS%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>数据算法</title>
    <link href="http://lvjunxue.com/2018/10/10/%E6%95%B0%E6%8D%AE%E7%AE%97%E6%B3%95/"/>
    <id>http://lvjunxue.com/2018/10/10/数据算法/</id>
    <published>2018-10-10T06:43:15.000Z</published>
    <updated>2018-10-11T01:55:20.360Z</updated>
    
    <content type="html"><![CDATA[<p>最近面试，被虐的很惨，实话实说，日常开发的东西基本上都会，有些不会的直接在stackoverflow上随便找找基本上都可以解决问题。面试的时候很多都是基础，平时遇见问题，google一下就带过了，也不会特意的背代码，很多问题都是碰见过，能解决，具体过程是真的忘了。所以有了以下这篇文章，想来一篇算法的，在来一份基础面试题，再之后写一篇面试的小问题吧。还有有一些答案不是最好的如果您有更好的，请给我留言，大家一起进步。—–来自一个非计算机专业的小白整理，请勿嘲笑。</p><a id="more"></a><p>1、交换A和B两个值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">用中间参数</span><br><span class="line">void swap(int a, int b) &#123;</span><br><span class="line">    int temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br><span class="line">不用中间参数</span><br><span class="line">void swap(int a, int b) &#123;</span><br><span class="line">    a = a + b;</span><br><span class="line">    b = a - b;</span><br><span class="line">    a = a - b;</span><br><span class="line">&#125;</span><br><span class="line">void swap(int a, int b) &#123;</span><br><span class="line">    a = a ^ b;</span><br><span class="line">    b = a ^ b;</span><br><span class="line">    a = a ^ b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>2、模拟栈操作<br>栈是一种数据结构，特点：先进后出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">栈最多能保存1024个数据</span><br><span class="line">static int data[1024];</span><br><span class="line">目前已经放了多少个数</span><br><span class="line">static int count = 0;</span><br><span class="line">数据入栈 push</span><br><span class="line">void push(int x) &#123;</span><br><span class="line">    防止数组越界</span><br><span class="line">    assert(!full());</span><br><span class="line">    data[count++] = x;</span><br><span class="line">&#125;</span><br><span class="line">数据出栈 pop</span><br><span class="line">int pop() &#123;</span><br><span class="line">    assert(!empty());</span><br><span class="line">    return data[--count];</span><br><span class="line">&#125;</span><br><span class="line">查看栈顶元素 top</span><br><span class="line">int top() &#123;</span><br><span class="line">    assert(!empty());</span><br><span class="line">    return data[count-1];</span><br><span class="line">&#125;</span><br><span class="line">查询栈满 full</span><br><span class="line">bool full() &#123;</span><br><span class="line">    if(count &gt;= 1024) &#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">查询栈空 empty</span><br><span class="line">bool empty() &#123;</span><br><span class="line">    if(count &lt;= 0) &#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    入栈</span><br><span class="line">    for (int i = 1; i &lt;= 10; i++) &#123;</span><br><span class="line">        push(i);</span><br><span class="line">    &#125;</span><br><span class="line">    出栈</span><br><span class="line">    while(!empty()) &#123;</span><br><span class="line">        栈顶元素</span><br><span class="line">        printf(&quot;%d &quot;, top());</span><br><span class="line">        出栈</span><br><span class="line">        pop();</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>3、排序<br>冒泡排序<br>最差时间复杂度 O(n^2)<br>平均时间复杂度 O(n^2)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (void)bubbleAscendingOrderSortWithArray:(NSMutableArray *)arr &#123;</span><br><span class="line">    for (int i = 0; i &lt; arr.count; i++) &#123;</span><br><span class="line">        for (int j = 0; j &lt; arr.count - 1 - i;j++) &#123;</span><br><span class="line">            if ([arr[j+1] intValue] &lt; [arr[j] intValue]) &#123;</span><br><span class="line">                int temp = [arr[j] intValue];</span><br><span class="line">                arr[j] = arr[j + 1];</span><br><span class="line">                arr[j + 1] = [NSNumber numberWithInt:temp];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>选择排序<br>平均时间复杂度：O(n^2)<br>平均空间复杂度：O(1)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">- (void)selectionAscendingOrderSortWithArray:(NSMutableArray *)arr &#123;</span><br><span class="line">    for (int i = 0; i &lt; arr.count; i ++) &#123;</span><br><span class="line">        int index = i;</span><br><span class="line">        for (int j = i + 1; j &lt; arr.count; j ++) &#123;</span><br><span class="line">            if ([arr[index] intValue] &gt; [arr[j] intValue]) &#123;</span><br><span class="line">                index = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(index != i) &#123;</span><br><span class="line">            int temp = [arr[i] intValue];</span><br><span class="line">            arr[i] = arr[index];</span><br><span class="line">            arr[index] = [NSNumber numberWithInt:temp];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>插入排序<br>平均时间复杂度：O(n^2)<br>平均空间复杂度：O(1)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (void)insertionAscendingOrderSort:(NSMutableArray *)arr &#123;</span><br><span class="line">    for (int i = 1; i &lt; arr.count; i ++) &#123;</span><br><span class="line">        int temp = [arr[i] intValue];</span><br><span class="line">        for (int j = i - 1; j &gt;= 0 &amp;&amp; temp &lt; [arr[j] intValue]; j --) &#123;</span><br><span class="line">            arr[j + 1] = arr[j];</span><br><span class="line">            arr[j] = [NSNumber numberWithInteger:temp];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>快速排序<br>平均时间复杂度：O(n^2)<br>平均空间复杂度：O(nlogn)       O(nlogn)~O(n^2)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">- (void)quickSortArray:(NSMutableArray *)array withLeftIndex:(NSInteger)leftIndex andRightIndex:(NSInteger)rightIndex &#123;</span><br><span class="line">    if (leftIndex &gt;= rightIndex) &#123;</span><br><span class="line">        return ;</span><br><span class="line">    &#125;</span><br><span class="line">    NSInteger i = leftIndex;</span><br><span class="line">    NSInteger j = rightIndex;</span><br><span class="line">    NSInteger key = [array[i] intValue];</span><br><span class="line">    while (i &lt; j) &#123;</span><br><span class="line">        while (i &lt; j &amp;&amp; [array[j] intValue] &gt;= key) &#123;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        array[i] = array[j];</span><br><span class="line">        while (i &lt; j &amp;&amp; [array[i] intValue] &lt;= key) &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        array[j] = array[i];</span><br><span class="line">    &#125;</span><br><span class="line">    array[i] = @(key);</span><br><span class="line">    [self quickSortArray:array withLeftIndex:leftIndex andRightIndex:i - 1];</span><br><span class="line">    [self quickSortArray:array withLeftIndex:i + 1 andRightIndex:rightIndex];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>希尔排序<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p><p>4、逆序字符串<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">不开辟空间新建字符串</span><br><span class="line">char* Reverse(char* s) &#123;</span><br><span class="line">    char* q = s ;</span><br><span class="line">    while( *q++ ) ;</span><br><span class="line">    q -= 2 ; </span><br><span class="line"></span><br><span class="line">    char* p = newchar[sizeof(char) * (q - s + 2)] ; </span><br><span class="line">    char* r = p ;</span><br><span class="line"></span><br><span class="line">    while(q &gt;= s)</span><br><span class="line">    *p++ = *q-- ;</span><br><span class="line">    *p = &apos;\0&apos; ;</span><br><span class="line"></span><br><span class="line">    return r ;</span><br><span class="line">&#125;</span><br><span class="line">中间字符串</span><br><span class="line">- (NSString*)reverseWordsInString:(NSString*)oldStr &#123;</span><br><span class="line">    NSMutableString *newStr = [[NSMutableString alloc] initWithCapacity:oldStr.length];</span><br><span class="line">    for (int i = oldStr.length - 1; i &gt;= 0; i --) &#123;</span><br><span class="line">        unichar character = [oldStr characterAtIndex:i];</span><br><span class="line">        [newStr appendFormat:@&quot;%c&quot;,character];</span><br><span class="line">    &#125;</span><br><span class="line">    return newStr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>5、链表翻转<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">node* reverseList(node* H) &#123; </span><br><span class="line">    if (H == NULL || H-&gt;next == NULL) //链表为空或者仅1个数直接返回</span><br><span class="line">    return H;</span><br><span class="line">    node* p = H, *newH = NULL; </span><br><span class="line">    while (p != NULL) //一直迭代到链尾 &#123; </span><br><span class="line">        node* tmp = p-&gt;next; //暂存p下一个地址，防止变化指针指向后找不到后续的数</span><br><span class="line">        p-&gt;next = newH; //p-&gt;next指向前一个空间 </span><br><span class="line">        newH = p; //新链表的头移动到p，扩长一步链表 </span><br><span class="line">        p = tmp; //p指向原始链表p指向的下一个空间 </span><br><span class="line">    &#125; </span><br><span class="line">    return newH; </span><br><span class="line">&#125;</span><br><span class="line">递归方式</span><br><span class="line">node* In_reverseList(node* H) &#123; </span><br><span class="line">    if (H == NULL || H-&gt;next == NULL) //链表为空直接返回，而H-&gt;next为空是递归基 </span><br><span class="line">        return H; </span><br><span class="line">    node* newHead = In_reverseList(H-&gt;next); //一直循环到链尾</span><br><span class="line">    H-&gt;next-&gt;next = H; //翻转链表的指向 </span><br><span class="line">    H-&gt;next = NULL; //记得赋值NULL，防止链表错乱 </span><br><span class="line">    return newHead; //新链表头永远指向的是原链表的链尾</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>6、求最大公约数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">int gcd(int a, int b) &#123;</span><br><span class="line">    int temp = 0;</span><br><span class="line">    if (a &lt; b) &#123;</span><br><span class="line">        temp = a;</span><br><span class="line">        a = b;</span><br><span class="line">        b = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    while (b != 0) &#123;</span><br><span class="line">        temp = a % b;</span><br><span class="line">        a = b;</span><br><span class="line">        b = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    return a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>7、从1亿个浮点数里找出最大的10个<br>第一想法都是排序之后再取前10个，但是呢效率不行。本人第二想法就是取前十个排序，在从剩下的一个一个替换掉，最后得到10个最大的数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (void)findMaxNum:(NSMutableArray *)arr &#123;</span><br><span class="line">    NSMutableArray * myArr = [[NSMutableArray alloc] initWithArray:[arr subarrayWithRange:NSMakeRange(0, 10)]];</span><br><span class="line">    [self quickSortArray:myArr withLeftIndex:0 andRightIndex:myArr.count - 1];</span><br><span class="line">    for (int i = 10; i &lt; arr.count - 1; i++) &#123;</span><br><span class="line">        if ([arr[i] intValue] &gt; [myArr[0] intValue]) &#123;</span><br><span class="line">            myArr[0] = arr[i];</span><br><span class="line">            [self quickSortArray:myArr withLeftIndex:0 andRightIndex:myArr.count - 1];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>8、数组去重<br>如果是OC的话，可以用NSSet的唯一性来去掉重复的字段。还有一些系统提供的方法，还有谓词搜索筛选。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">- (void)findRepeatNum:(NSMutableArray *)arr &#123;</span><br><span class="line">    NSMutableArray *myArr = [NSMutableArray array];</span><br><span class="line">    for (int i = 0; i &lt; arr.count; i++) &#123;</span><br><span class="line">        BOOL isHave = NO;</span><br><span class="line">        for (int j = 0; j &lt; myArr.count; j++) &#123;</span><br><span class="line">            if ([arr[i] intValue] == [myArr[j] intValue]) &#123;</span><br><span class="line">                isHave = YES;</span><br><span class="line">                break;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                isHave = NO;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (!isHave) &#123;</span><br><span class="line">            [myArr addObject:arr[i]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>9、二分法查找<br>二分只适用于有序的数组查找<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">- (NSInteger)binarySearch:(NSArray *)array target:(NSInteger)target &#123;</span><br><span class="line">    if (array.count == 0) &#123;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    NSInteger start = 0;</span><br><span class="line">    NSInteger end = array.count - 1;</span><br><span class="line">    NSInteger mid = 0;</span><br><span class="line">    while (start + 1 &lt; end) &#123;</span><br><span class="line">        mid = start + (end - start) / 2;</span><br><span class="line">        if ([array[mid] integerValue] == target) &#123;</span><br><span class="line">            return mid;</span><br><span class="line">        &#125; else if ([array[mid] integerValue] &lt; target) &#123;</span><br><span class="line">            start = mid;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            end = mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if ([array[start] integerValue] == target) &#123;</span><br><span class="line">        return start;</span><br><span class="line">    &#125;</span><br><span class="line">    if ([array[end] integerValue] == target) &#123;</span><br><span class="line">        return end;</span><br><span class="line">    &#125;</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>10、求最大值和最小值，这个太简单了。。。<br>第一个为最大值或最小值，一个for循环比下去。</p><p>11、二叉树遍历<br>先序遍历-中左右<br>中序遍历-左中右<br>后续遍历-左右中</p><p>算法的我就先整理几个，后续会新增一些面试过程遇到的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近面试，被虐的很惨，实话实说，日常开发的东西基本上都会，有些不会的直接在stackoverflow上随便找找基本上都可以解决问题。面试的时候很多都是基础，平时遇见问题，google一下就带过了，也不会特意的背代码，很多问题都是碰见过，能解决，具体过程是真的忘了。所以有了以下这篇文章，想来一篇算法的，在来一份基础面试题，再之后写一篇面试的小问题吧。还有有一些答案不是最好的如果您有更好的，请给我留言，大家一起进步。—–来自一个非计算机专业的小白整理，请勿嘲笑。&lt;/p&gt;
    
    </summary>
    
    
      <category term="-iOS进阶" scheme="http://lvjunxue.com/tags/iOS%E8%BF%9B%E9%98%B6/"/>
    
  </entry>
  
  <entry>
    <title>ijkplayer</title>
    <link href="http://lvjunxue.com/2017/09/10/ijkplayer/"/>
    <id>http://lvjunxue.com/2017/09/10/ijkplayer/</id>
    <published>2017-09-10T11:27:11.000Z</published>
    <updated>2018-09-10T15:44:31.596Z</updated>
    
    <content type="html"><![CDATA[<p>生活不易啊，继续学习啊ijkplayer。</p><a id="more"></a><p><a href="https://github.com/Bilibili/ijkplayer" target="_blank" rel="noopener">B站GitHub</a>，先下载个ijkplayer吧。</p><p>默认为最少支持, 如果足够你使用, 可以跳过这一步. 否则可以改为以下配置:<br>module-default.sh 更多的编解码器/格式<br>module-lite-hevc.sh 较少的编解码器/格式(包括hevc)<br>module-lite.sh 较少的编解码器/格式(默认情况)</p><p>进入 config 目录<br>cd config<br>删除当前的 module.sh 文件<br>rm module.sh<br>可根据需要替换为<code>module-default.sh</code>, <code>module-lite-hevc.sh</code>, <code>module-lite.sh</code><br>创建软链接 module.sh 指向 module-lite-hevc.sh<br>ln -s module-lite-hevc.sh module.sh</p><p>em…编译，过程需要下载ffmpeg，毕竟基于ffmpeg嘛。打开终端，cd到ijkplayer-master，执行 ./init-ios.sh 时间可能会有点长。</p><p>支持https设置<br>获取 openssl 并初始化<br>./init-ios-openssl.sh</p><p>启用 openssl 组件方法<br>echo ‘export COMMON_FF_CFG_FLAGS=”$COMMON_FF_CFG_FLAGS –enable-openssl”‘ &gt;&gt; ../config/module.sh<br>或者<br>vim ../config/module.sh<br>export COMMON_FF_CFG_FLAGS=”$COMMON_FF_CFG_FLAGS –enable-openssl”</p><p>cd ios<br>./compile-ffmpeg.sh clean<br>./compile-openssl.sh all<br>过程是屏幕一顿飞，会出现警告，别慌！！！<br>如果不需要https以上步骤可以省略掉。</p><p>执行 ./compile-ffmpeg.sh all 中间可能会卡顿一下，然后一顿滚屏，别停止了喔。</p><p>./libavutil/arm/asm.S:50:9: error: unknown directive<br>.arch armv7-a<br>^</p><p>如果出这个错误。在 compile-ffmpeg.sh 中删除 armv7<br>FF_ALL_ARCHS_IOS8_SDK=”arm64 i386 x86_64”<br>再重新执行: ./compile-ffmpeg.sh all</p><p>然后运行IJKMediaDemo。把libcrypto.a和libssl.a加进去。</p><p>应该就可以使用了。只能看看在线的给你们一个地址试试吧，<a href="http://clips.vorwaerts-gmbh.de/big_buck_bunny.mp4" target="_blank" rel="noopener">http://clips.vorwaerts-gmbh.de/big_buck_bunny.mp4</a></p><p><a href="https://gcs-vimeo.akamaized.net/exp=1536608263~acl=%2A%2F623685558.mp4%2A~hmac=ac4bea3eee7fd318322ce65b675f742017a84c294aa0ac57f8480aa9bfd80037/vimeo-prod-skyfire-std-us/01/2670/7/188350983/623685558.mp4" target="_blank" rel="noopener">https://gcs-vimeo.akamaized.net/exp=1536608263~acl=%2A%2F623685558.mp4%2A~hmac=ac4bea3eee7fd318322ce65b675f742017a84c294aa0ac57f8480aa9bfd80037/vimeo-prod-skyfire-std-us/01/2670/7/188350983/623685558.mp4</a></p><p>打包 framwork完成最后的工作！！！<br>open IJKMediaPlayer/IJKMediaPlayer.xcodeproj</p><p>配置 Release 模式<br>打包真机 framework<br>如果之前删除了armv7，注释include “armv7/avconfig.h”<br>command+b<br>打包模拟器 framework<br>command+b<br>在Products里有IJKMediaFramework.framework，右键，show in Finder</p><p>合并 framework</p><p>cd 到 Products目录下lipo -create 真机framework路径 模拟器framework路径 -output 合并的文件路径</p><p>lipo -create Release-iphoneos/IJKMediaFramework.framework/IJKMediaFramework Release-iphonesimulator/IJKMediaFramework.framework/IJKMediaFramework -output IJKMediaFramework</p><p>生成了IJKMediaFramework文件，拖入真机或模拟器的framework中，替换掉之前的IJKMediaFramework，之后IJKMediaFramework.framework可以导入工程了。</p><p>添加下列依赖到工程<br>libc++.tbd<br>libz.tbd<br>libbz2.tbd<br>AudioToolbox.framework<br>UIKit.framework<br>CoreGraphics.framework<br>AVFoundation.framework<br>CoreMedia.framework<br>CoreVideo.framework<br>MediaPlayer.framework<br>MobileCoreServices.framework<br>OpenGLES.framework<br>QuartzCore.framework<br>VideoToolbox.framework</p><p>在Header Search Paths加入头文件的路径。</p><p>另外如果要支持rtsp<br>在 ijkplayer-master 下的 config 中，打开 module-lite.sh<br>将 export COMMON_FF_CFG_FLAGS=”$COMMON_FF_CFG_FLAGS –disable-protocol=rtp”<br>修改为 export COMMON_FF_CFG_FLAGS=”$COMMON_FF_CFG_FLAGS –enable-protocol=rtp”<br>并添加 export COMMON_FF_CFG_FLAGS=”$COMMON_FF_CFG_FLAGS –enable-demuxer=rtsp”<br>export COMMON_FF_CFG_FLAGS=”$COMMON_FF_CFG_FLAGS –enable-decoder=mjpeg”<br>export COMMON_FF_CFG_FLAGS=”$COMMON_FF_CFG_FLAGS –enable-demuxer=mjpeg”<br>然后命令行执行:<br>rm module.sh<br>ln -s module-lite.sh module.sh<br>在执行cd到ios那步。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;生活不易啊，继续学习啊ijkplayer。&lt;/p&gt;
    
    </summary>
    
    
      <category term="-iOS进阶" scheme="http://lvjunxue.com/tags/iOS%E8%BF%9B%E9%98%B6/"/>
    
  </entry>
  
  <entry>
    <title>ReactNative</title>
    <link href="http://lvjunxue.com/2017/09/10/ReactNative/"/>
    <id>http://lvjunxue.com/2017/09/10/ReactNative/</id>
    <published>2017-09-10T11:27:11.000Z</published>
    <updated>2018-10-10T06:43:24.485Z</updated>
    
    <content type="html"><![CDATA[<p>ReactNative内容。此文只献给那些没用过，还在排坑的小伙伴们。有错误内容还请指出。</p><a id="more"></a><p><a href="https://reactnative.cn/docs/integration-with-existing-apps/" target="_blank" rel="noopener">集成到现有原生应用</a>如过你还没有安装过或者没使用过，去中文网查看相关流程。</p><p>pod文件内加入基本的配置<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">pod 'React', :path =&gt; './RNComponent/node_modules/react-native', :subspecs =&gt; [</span><br><span class="line">    'Core',</span><br><span class="line">    'CxxBridge', # 如果RN版本 &gt;= 0.47则加入此行</span><br><span class="line">    'DevSupport', # 如果RN版本 &gt;= 0.43，则需要加入此行才能开启开发者菜单</span><br><span class="line">    'RCTText',</span><br><span class="line">    'RCTNetwork',</span><br><span class="line">    'RCTWebSocket', # 调试功能需要此模块</span><br><span class="line">    'RCTAnimation', # FlatList和原生动画功能需要此模块</span><br><span class="line">    <span class="meta">#在这里继续添加你所需要的其他RN模块</span></span><br><span class="line">]</span><br><span class="line"><span class="meta">#如果你的RN版本 &gt;= 0.42.0，则加入下面这行</span></span><br><span class="line">pod 'yoga', :path =&gt; './RNComponent/node_modules/react-native/ReactCommon/yoga'</span><br><span class="line"></span><br><span class="line"><span class="meta">#如果RN版本 &gt;= 0.45则加入下面三个第三方编译依赖</span></span><br><span class="line">pod 'DoubleConversion', :podspec =&gt; './RNComponent/node_modules/react-native/third-party-podspecs/DoubleConversion.podspec'</span><br><span class="line">pod 'glog', :podspec =&gt; './RNComponent/node_modules/react-native/third-party-podspecs/glog.podspec'</span><br><span class="line">pod 'Folly', :podspec =&gt; './RNComponent/node_modules/react-native/third-party-podspecs/Folly.podspec'</span><br></pre></td></tr></table></figure></p><p>具体内容我就不说了。记录下我的错误问题。</p><p>version0.57.1版本的时候出现问题记录：<br>[!] CocoaPods could not find compatible versions for pod “Folly”:<br>In Podfile:<br>Folly (from <code>./RNComponent/node_modules/react-native/third-party-podspecs/Folly.podspec</code>)</p><p>Specs satisfying the <code>Folly (from</code>./RNComponent/node_modules/react-native/third-party-podspecs/Folly.podspec<code>)</code> dependency were found, but they required a higher minimum deployment target.</p><p>三个第三方编译依赖Folly需要9.0以上：<br>修改platform :ios,’9.0’<br>they required a higher minimum deployment target.这句话提示怎么做。</p><p>如果你使用MLeaksFinder间接导入FBRetainCycleDetector。运行app会报错<br>Array has incomplete element type ‘struct rcd_rebinding’</p><p>原因是RN和FBRetainCycleDetector里都有<br>fishhook.c<br>fishhook.h<br>把FBRetainCycleDetector里的修改成<br>rcd_fishhook.c<br>rcd_fishhook.h<br>或者，坐等facebook更新喽。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;ReactNative内容。此文只献给那些没用过，还在排坑的小伙伴们。有错误内容还请指出。&lt;/p&gt;
    
    </summary>
    
    
      <category term="-iOS进阶" scheme="http://lvjunxue.com/tags/iOS%E8%BF%9B%E9%98%B6/"/>
    
  </entry>
  
  <entry>
    <title>Cocoa Touch</title>
    <link href="http://lvjunxue.com/2017/08/20/Cocoa%20Touch/"/>
    <id>http://lvjunxue.com/2017/08/20/Cocoa Touch/</id>
    <published>2017-08-20T13:34:27.000Z</published>
    <updated>2018-08-21T03:41:13.657Z</updated>
    
    <content type="html"><![CDATA[<p>Cocoa Touch就是指Foundation框架和UIKit框架。</p><a id="more"></a><p>系统最上层的，编写代码的时候，先看看这层提供的技术是否能满足你的需求，如果能，就用。不行在往下层去搞。</p><p>Cocoa Touch都有啥</p><p>Message UI<br>提供了App集成邮件与短信的支持。支持包括在App界面中弹出一个视图控制器界面。可以在该视图控制器中填入接收者，主题，主要内容和任意你想包含在信息里的附件。在弹出该视图控制器后，用户可以选择在发送之前对其做出编辑。</p><p>Address Book UI<br>一个Object-C编程接口，用来显示创建新联系人和编辑已经存在联系人信息的标准系统联系人界面。该框架简化了在App中显示联系人信息的操作，同时保证所有App的联系人界面在同一平台上都相同。</p><p>EventKit UI<br>提供了可以弹出查看和编辑日程相关事件的标准系统界面的视图控制器。该框架建立在EventKit框架的事件相关数据之上。</p><p>GameKit<br>实现了对Game Centre的支持，Game Center让用户可以在线分享游戏相关数据。</p><p>iAd<br>让App实现横幅广告的展示。广告会嵌入到你的交互界面的标准视图中，并在需要的时候弹出。</p><p>MapKit<br>提供可嵌入到App的用户界面中的可拖拽地图。可以使用该框架来自定义地图的内容与外观。</p><p>NotificationCenter<br>提供创建在通知中心里显示信息的小部件的功能。</p><p>PushKit<br>提供VoIP App的注册使用支持。该框架替代了之前注册VoIP App的API。</p><p>UIKit<br>提供了实现绘图和事件驱动App的重要基础。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Cocoa Touch就是指Foundation框架和UIKit框架。&lt;/p&gt;
    
    </summary>
    
    
      <category term="-iOS进阶" scheme="http://lvjunxue.com/tags/iOS%E8%BF%9B%E9%98%B6/"/>
    
  </entry>
  
  <entry>
    <title>离屏渲染问题</title>
    <link href="http://lvjunxue.com/2017/04/02/GPU%E7%A6%BB%E5%B1%8F%E6%B8%B2%E6%9F%93/"/>
    <id>http://lvjunxue.com/2017/04/02/GPU离屏渲染/</id>
    <published>2017-04-02T11:04:18.000Z</published>
    <updated>2018-08-16T06:23:38.534Z</updated>
    
    <content type="html"><![CDATA[<p>这个是我没事的时候在Stackoverflow瞎溜达时候看的</p><a id="more"></a><p>什么是离屏渲染？</p><p>GPU了解下？</p><p>OpenGL的中，GPU屏幕渲染有两种方式。<br>屏幕渲染（当前屏幕渲染）指的是GPU的渲染操作是在当前用于显示的屏幕缓冲区进行。<br>离屏渲染（离屏渲染）指的是在GPU在当前屏幕缓冲区以外开辟一个缓冲区进行渲染操作。<br>当发生离屏的时候，可能导致FPS下降，说白了，卡顿。人眼的辨识是30+</p><p>什么时候会发生离屏渲染</p><p>光栅化、遮罩、阴影、抗锯齿、不透明、复杂形状设置圆角等等，所以新建的空间如果能透明就透明。</p><p>怎么检测呢？<br>Instruments的Core Animation工具中有几个和离屏渲染相关的检查选项：<br>Color Offscreen-Rendered Yellow<br>开启后会把那些需要离屏渲染的图层高亮成黄色，这就意味着黄色图层可能存在性能问题。<br>Color Hits Green and Misses Red</p><p>更新下，改版了新的Xcode<br>（Debug）-（View Debugging）-（Rendering）-（Color Offscreen-Rendered Yellow）</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这个是我没事的时候在Stackoverflow瞎溜达时候看的&lt;/p&gt;
    
    </summary>
    
    
      <category term="-iOS进阶" scheme="http://lvjunxue.com/tags/iOS%E8%BF%9B%E9%98%B6/"/>
    
  </entry>
  
  <entry>
    <title>捕获Crash</title>
    <link href="http://lvjunxue.com/2017/03/09/Crash%E6%94%B6%E9%9B%86/"/>
    <id>http://lvjunxue.com/2017/03/09/Crash收集/</id>
    <published>2017-03-09T04:00:12.000Z</published>
    <updated>2018-09-05T23:46:00.736Z</updated>
    
    <content type="html"><![CDATA[<p>新需求～捕获Crash，虽然我每次提交代码之后都会说没BUG，测试吧。。。处女座，不能说没有，很少吧。</p><a id="more"></a><p>iTunes Connect的App分析中有，但是需要用户来设置，所以呢，没啥大用！！！</p><p>很多第三方也可以做，比如友盟移动统计，Mob移动统计，百度移动统计等等。</p><p>如果你想自己实现呢？</p><p>我给你俩工具，具体如何来做。。。那就看你学不学习了</p><p>DSYMTools分析工具,和邮件发送SKPSMTPMessage。</p><p>兄die，加油了。</p><p>Plcrashreporter听说这个很多大公司在用。了解下。。。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;新需求～捕获Crash，虽然我每次提交代码之后都会说没BUG，测试吧。。。处女座，不能说没有，很少吧。&lt;/p&gt;
    
    </summary>
    
    
      <category term="-iOS进阶" scheme="http://lvjunxue.com/tags/iOS%E8%BF%9B%E9%98%B6/"/>
    
  </entry>
  
  <entry>
    <title>hexo图片放置七牛云</title>
    <link href="http://lvjunxue.com/2017/03/06/hexo%E5%9B%BE%E7%89%87%E6%94%BE%E7%BD%AE%E4%B8%83%E7%89%9B%E4%BA%91/"/>
    <id>http://lvjunxue.com/2017/03/06/hexo图片放置七牛云/</id>
    <published>2017-03-06T03:44:25.000Z</published>
    <updated>2018-08-16T05:09:18.411Z</updated>
    
    <content type="html"><![CDATA[<p>其实这是一个测试我配置完的博文，七牛放置图片很简单，百度一下就很多了。</p><a id="more"></a><p><img src="http://p55cuazcg.bkt.clouddn.com/6.jpg" alt="image"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;其实这是一个测试我配置完的博文，七牛放置图片很简单，百度一下就很多了。&lt;/p&gt;
    
    </summary>
    
    
      <category term="-hexo记录" scheme="http://lvjunxue.com/tags/hexo%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>组件化</title>
    <link href="http://lvjunxue.com/2017/03/03/iOS%E7%BB%84%E4%BB%B6%E5%8C%96/"/>
    <id>http://lvjunxue.com/2017/03/03/iOS组件化/</id>
    <published>2017-03-03T09:00:12.000Z</published>
    <updated>2018-08-16T05:56:15.826Z</updated>
    
    <content type="html"><![CDATA[<p>封装、封装再封装。如果你是单人开发，这么高耦合的代码会加速你的开发。但是，有时候业务逻辑有所改变，你会把项目改的很乱</p><a id="more"></a><p>Url-Block、Protocol-Class(Url-Controller)、Target-Action</p><p>思路都是走一个路由（中间件）来完成页面之间的传递信息。</p><p>网上的已经满天的文章了，具体内容我就不多说了。</p><p>我说一下一个项目是否该用组件化，怎么选择。</p><p>如果你是单人开发，公司的项目设计的业务不是特别多，你可以不考虑组件化，毕竟单人开发的时候有很多地方个人感觉完全没必要，只要不写很多高度耦合的代码出来一个MVVM可以应对项目。</p><p>如果不是单人开发，项目中设计的业务也比较广泛，还有公司可以会有多个业务，很多内容的功能都是类似的，可以考虑用组建来做。毕竟很多基础组建写好之后，可以在很多项目中重用。</p><p>至于选择，其实每个都有自己的优劣，不要被选择困惑。我个人比较喜欢Target-Action多一点。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;封装、封装再封装。如果你是单人开发，这么高耦合的代码会加速你的开发。但是，有时候业务逻辑有所改变，你会把项目改的很乱&lt;/p&gt;
    
    </summary>
    
    
      <category term="-iOS进阶" scheme="http://lvjunxue.com/tags/iOS%E8%BF%9B%E9%98%B6/"/>
    
  </entry>
  
  <entry>
    <title>无痕埋点</title>
    <link href="http://lvjunxue.com/2017/02/03/iOS%E6%97%A0%E7%97%95%E5%9F%8B%E7%82%B9/"/>
    <id>http://lvjunxue.com/2017/02/03/iOS无痕埋点/</id>
    <published>2017-02-03T08:08:49.000Z</published>
    <updated>2018-08-16T05:37:19.721Z</updated>
    
    <content type="html"><![CDATA[<p>以前都是手动来埋，有时候会忘记，研究了下无痕埋点，省掉了很多东西</p><a id="more"></a><p>Google了很多文章，发现都是面向切面的AOP思想来做的，总结起来就是偷梁换柱的Runtime黑魔法。</p><p>先来一大推的分类。来来来，统一替换埋点的方法。部分点击的分类要考虑深一点，比如UIButton使用UIControl会比较好，UIControl还包含了其他的一些控件。</p><p>那我怎么知道是哪个页面？</p><p>来个plist文件对应表～</p><ul><li><p>(NSString <em>)pageEventID:(BOOL)enterPage<br>{<br>  NSDictionary </em>configDict = [self dictionaryFromUserStatisticsConfigPlist];<br>  NSString *selfClassName = NSStringFromClass([self class]);<br>  return configDict[selfClassName][@”PageEventIDs”][enterPage ? @”Enter” : @”Leave”];<br>}</p></li><li><p>(NSDictionary <em>)dictionaryFromUserStatisticsConfigPlist<br>{<br>  NSString </em>filePath = [[NSBundle mainBundle] pathForResource:@”Config” ofType:@”plist”];<br>  NSDictionary *dic = [NSDictionary dictionaryWithContentsOfFile:filePath];<br>  return dic;<br>}</p></li></ul><p>可能是记录blog，所以写的比较粗糙。</p><p>还有埋点的时候要善于使用XCTAssert。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;以前都是手动来埋，有时候会忘记，研究了下无痕埋点，省掉了很多东西&lt;/p&gt;
    
    </summary>
    
    
      <category term="-iOS进阶" scheme="http://lvjunxue.com/tags/iOS%E8%BF%9B%E9%98%B6/"/>
    
  </entry>
  
  <entry>
    <title>WebRTC</title>
    <link href="http://lvjunxue.com/2017/01/05/WebRTC/"/>
    <id>http://lvjunxue.com/2017/01/05/WebRTC/</id>
    <published>2017-01-05T05:09:33.000Z</published>
    <updated>2018-08-29T02:20:53.483Z</updated>
    
    <content type="html"><![CDATA[<p>WebRTC内容，简单集成。</p><a id="more"></a><p>搞个环境吧。。。</p><p><a href="http://www.cnblogs.com/fulianga/p/5868823.html下载编译" target="_blank" rel="noopener">http://www.cnblogs.com/fulianga/p/5868823.html下载编译</a><br>如果你要试试功能，去gitHub上随便找一个版本就行了。</p><p>一个头文件的文件夹，加一个.a文件。</p><p>导入系统依赖库<br>CoreMedia.framework<br>AVFoundation.framework<br>AudioToolbox.framework<br>GLKit.framework<br>OpenGLES.framework<br>VideoToolbox.framework<br>libicucore.tbd<br>libstdc++.6.tbd<br>libc++.tbd<br>libresolv.tbd<br>libxml2.tbd<br>OK环境完事了。</p><p>WebRTC主要实现了三个API，分别是:<br>MediaStream：通过MediaStream的API能够通过设备的摄像头及话筒获得视频、音频的同步流。<br>RTCPeerConnection：RTCPeerConnection是WebRTC用于构建点对点之间稳定、高效的流传输的组件。<br>RTCDataChannel：RTCDataChannel使得浏览器之间（点对点）建立一个高吞吐量、低延时的信道，用于传输任意数据。<br>其中RTCPeerConnection是我们WebRTC的核心组件。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">WebRTCHelperDelegate</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">WebRTCHelper</span> : <span class="title">NSObject</span>&lt;<span class="title">SRWebSocketDelegate</span>&gt;</span></span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">instancetype</span>)sharedInstance;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>)<span class="keyword">id</span>&lt;WebRTCHelperDelegate&gt; delegate;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*  与服务器建立连接</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*  @param server 服务器地址</span></span><br><span class="line"><span class="comment">*  @param room   房间号</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">- (<span class="keyword">void</span>)connectServer:(<span class="built_in">NSString</span> *)server port:(<span class="built_in">NSString</span> *)port room:(<span class="built_in">NSString</span> *)room;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*  退出房间</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">- (<span class="keyword">void</span>)exitRoom;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">WebRTCHelperDelegate</span> &lt;<span class="title">NSObject</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@optional</span></span><br><span class="line">- (<span class="keyword">void</span>)webRTCHelper:(WebRTCHelper *)webRTChelper setLocalStream:(RTCMediaStream *)stream userId:(<span class="built_in">NSString</span> *)userId;</span><br><span class="line">- (<span class="keyword">void</span>)webRTCHelper:(WebRTCHelper *)webRTChelper addRemoteStream:(RTCMediaStream *)stream userId:(<span class="built_in">NSString</span> *)userId;</span><br><span class="line">- (<span class="keyword">void</span>)webRTCHelper:(WebRTCHelper *)webRTChelper closeWithUserId:(<span class="built_in">NSString</span> *)userId;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>把所有的头文件都看一圈。。。em。。。反正没人看，我就是自己记录一下而已。</p><p>具体实现过程的文章。</p><p><a href="https://www.jianshu.com/p/c49da1d93df4" target="_blank" rel="noopener">iOS下音视频通信-基于WebRTC</a><br>还有一些即时通讯的文章，统一在这记录一下。。。<br><a href="https://www.jianshu.com/p/2dbb360886a8" target="_blank" rel="noopener">iOS即时通讯，从入门到“放弃”？</a><br><a href="https://www.jianshu.com/p/0a11b2d0f4ae" target="_blank" rel="noopener">iOS即时通讯进阶 - CocoaAsyncSocket源码解析(Connect篇)</a><br><a href="https://www.jianshu.com/p/22c984eac9b9" target="_blank" rel="noopener">iOS即时通讯进阶 - CocoaAsyncSocket源码解析(Connect篇终)</a><br><a href="https://www.jianshu.com/p/fdd3d429bdb3" target="_blank" rel="noopener">iOS即时通讯进阶 - CocoaAsyncSocket源码解析(Read篇)</a><br><a href="https://www.jianshu.com/p/19f0fd363f60" target="_blank" rel="noopener">iOS即时通讯进阶 - CocoaAsyncSocket源码解析(Read篇终)</a></p><p>上面的作者很用心，写了很多，多读读，其实简单实现还是很容易的。但是！！！你要知道你的Demo只面对了你自己，当你面对9亿网民的时候，有可能分分钟就被干趴了，还是要好好研究才能上项目的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;WebRTC内容，简单集成。&lt;/p&gt;
    
    </summary>
    
    
      <category term="-iOS进阶" scheme="http://lvjunxue.com/tags/iOS%E8%BF%9B%E9%98%B6/"/>
    
  </entry>
  
  <entry>
    <title>视频直播</title>
    <link href="http://lvjunxue.com/2017/01/03/iOS%E8%A7%86%E9%A2%91%E7%9B%B4%E6%92%AD/"/>
    <id>http://lvjunxue.com/2017/01/03/iOS视频直播/</id>
    <published>2017-01-03T11:05:44.000Z</published>
    <updated>2018-08-29T01:58:08.291Z</updated>
    
    <content type="html"><![CDATA[<p>现在第三方集成视频直播的有很多了，想完成一个其实一顿SDK很无脑的就能搞出一个APP。</p><a id="more"></a><p>鉴于对程序的热爱（必不得已）仔细的研究了整个视频直播的过程，具体实现没有做，很多大咖写的非常好了，写这篇播客的目的就是, 想记录一下当时的思路。</p><p>主播端：<br>1）需要做的音视频采集<br>2）视频处理、美颜滤镜之类的（毕竟主播要美美哒）<br>3）视频编码。<br>4）推流到服务器（RTMP,HLS,FLV）</p><p>用户端：<br>1）拉流。<br>2）解码。<br>3）观看。</p><p>用什么来做？em。。。<br>B站的ijkPlayer听过没。如果没有，那ffmpeg了解下。</p><p>在说一下其他的东西，如果真的想在图像视频方面深挖，学学OpenGL（ES）其实不错的。</p><p>WebRTC内容，之后在写吧。。。。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;现在第三方集成视频直播的有很多了，想完成一个其实一顿SDK很无脑的就能搞出一个APP。&lt;/p&gt;
    
    </summary>
    
    
      <category term="-iOS进阶" scheme="http://lvjunxue.com/tags/iOS%E8%BF%9B%E9%98%B6/"/>
    
  </entry>
  
  <entry>
    <title>远程Git仓库</title>
    <link href="http://lvjunxue.com/2016/08/10/%E8%BF%9C%E7%A8%8BGit%E4%BB%93%E5%BA%93/"/>
    <id>http://lvjunxue.com/2016/08/10/远程Git仓库/</id>
    <published>2016-08-10T11:05:44.000Z</published>
    <updated>2018-08-16T05:12:00.959Z</updated>
    
    <content type="html"><![CDATA[<p>脑子不好用了，总是忘记点啥，还是备注下吧</p><a id="more"></a><p>开始～～～～～～</p><p>远程私有仓库（分支仓库）</p><p>pod repo    看看有没有自己的！</p><p>pod repo add 私有库名字 你的私有库地址</p><p>pod lib create XXX                  然后一顿选择。</p><p>cd到目录下</p><p>添加git远程私有库关联    git remote查看，应该是没有的，如果你不相信就自己看下咯。</p><p>git remote add origin XXX</p><p>修改podspec文件<br>s.summary 、s.homepage、s.source、s.source_files等等，自行百度。<br>分支内容来了！！！！<br>s.source_files注释掉<br>s.subspec ‘XXX’ do |X|<br>    X.source_files = ‘路径’<br>    X.dependency = ‘其他库’<br>end</p><p>提交去远程仓库<br>$ git add .</p><ul><li>git add -A  提交所有变化</li><li>git add -u  提交被修改(modified)和被删除(deleted)文件，不包括新文件(new)</li><li>git add .  提交新文件(new)和被修改(modified)文件，不包括被删除(deleted)文件</li></ul><p>$ git status    看看是不是都变绿了</p><p>$ git commit -m “首次提交内容，等待上传其他基础组件”</p><p>上传代码<br>$ git push origin master</p><p>打标签，并且把标签提交到远程私地址$ git tag<br>$ git tag -a ‘0.1.0’ -m “标签显示内容”<br>上传标签    $ git push –tags</p><p>验证spec并提交到本地私有索引库<br>验证本地 $ pod lib lint<br>验证远程 $ pod spec lint<br>都通过后提交本地<br>$ pod repo push XXX XXX.podspec</p><p>使用的时候   soure’adress’</p><p>pod ‘spec’<br>pod ‘spec/xxx’<br>pod ‘spec’, :subspecs =&gt; [‘xxx’, ‘xxx’]</p><p>验证spec的时候如果你引用了私有的库    在验证后面加上–sources=地址,master     更多内容查看help</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;脑子不好用了，总是忘记点啥，还是备注下吧&lt;/p&gt;
    
    </summary>
    
    
      <category term="-环境搭建" scheme="http://lvjunxue.com/tags/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    
  </entry>
  
  <entry>
    <title>本地Git仓库</title>
    <link href="http://lvjunxue.com/2016/08/09/%E6%9C%AC%E5%9C%B0Git%E4%BB%93%E5%BA%93/"/>
    <id>http://lvjunxue.com/2016/08/09/本地Git仓库/</id>
    <published>2016-08-09T11:05:44.000Z</published>
    <updated>2018-08-16T05:12:09.837Z</updated>
    
    <content type="html"><![CDATA[<p>本地Git仓库搭建，小小渣渣给自己Blog留痕，大咖直接忽视，如果错误请指出。谢啦！</p><a id="more"></a><p>开始～～～～～～</p><p>mkdir MyGit 创建一个目录，cd到当前目录—&gt;MyGit，$ git init</p><p>Cookies-MacBook-Pro:MyGit Cookie$ git init<br>Initialized empty Git repository in /Users/Cookie/MyGit/.git/</p><p>？？？怎么什么都没有？？？</p><p>创建了一个隐藏的文件夹.git，我想看看文件夹里都有什么，嗯嗯，简单。输入下面的指令</p><p>$ defaults write com.apple.finder AppleShowAllFiles -bool true  //显示隐藏文件（false）<br>$ KillAll Finder</p><p>配置个人信息：<br>1、一次性的配置， 只会配置到被管理文件的.git文件夹</p><p>$ git config user.name Cookie<br>$ git config user.email <a href="mailto:373733319@qq.com" target="_blank" rel="noopener">373733319@qq.com</a></p><p>2、XX性的配置， 只会配置到被管理文件的.git文件夹</p><p>$ git config –global user.name Cookie<br>$ git config –global user.email <a href="mailto:373733319@qq.com" target="_blank" rel="noopener">373733319@qq.com</a></p><p>$ git config –list查看配置信息</p><p>go on</p><p>创建一个文件夹，名字叫CustomNavgationBar，然后把你想制作成pod库的文件夹复制进去。<br>如图：<br><img src="http://p55cuazcg.bkt.clouddn.com/WechatIMG292.jpeg" alt="image"></p><p>然后按顺序执行下面操作：</p><p>cd到上层的CustomNavgationBar</p><p>$ git add . &amp;&amp; git commit -m “commit my test code”（我也不知道干什么用的）</p><ul><li>git add -A  提交所有变化</li><li>git add -u  提交被修改(modified)和被删除(deleted)文件，不包括新文件(new)</li><li>git add .  提交新文件(new)和被修改(modified)文件，不包括被删除(deleted)文件</li><li>git commit - “提交的内容是啥”</li></ul><p>$ pod spec create CustomNavgationBar</p><p>然后你多了一个CustomNavgationBar.podspec文件，右键打开。具体工具看你电脑里有啥了。</p><p>修改如下位置：</p><p>s.source       = { :git =&gt; “/Users/Cookie/MyGit/CustomNavgationBar”, :tag =&gt; “#{s.version}” }<br>s.description  = &lt;&lt;-DESC<br>                                TODO: Add long description of the pod here.<br>                                DESC<br>s.license      = “MIT”<br>s.source_files  = “CustomNavgationBar”, “CustomNavgationBar/*<em>/</em>.{h,m}”<br>s.exclude_files = “CustomNavgationBar/Exclude”</p><p>然后回到pods文件添加本地库：<br>pod ‘CustomNavgationBar’, :path =&gt; ‘/Users/XXX/MyGit/CustomNavgationBar’</p><p>添加完成之后最后的步骤——————pod install，啊嘿！</p><p>我是用的XCode，然后在Pods下面有个叫Development Pods的文件夹，下面就是你刚刚Pods的文件喔！！！</p><p>就是感觉哪里不对，然后发现了新的东西！！！</p><p>pod lib create XXX                  然后一顿选择。<br>修改XXX的.podspec文件<br>s.source           = { :git =&gt; ‘/Users/Cookie/Desktop/NewProject/LJXMediator’, :tag =&gt; s.version.to_s }<br>s.source_files = ‘XXX/Classes/<strong>/*’<br>s.public_header_files = ‘XXX/Classes/</strong>/*.h’<br>依赖库<br>s.dependency ‘AFNetworking’, ‘~&gt; 2.3’</p><p>cd 到XXX的Example目录下，pod install</p><p>在其他的Podfile文件下pod ‘XXX’, :path =&gt; ‘/Users/Cookie/Desktop/NewProject/XXX’</p><p>pod install</p><hr><p>远程仓库</p><p>pod trunk register注册！！！！</p><p>github上创建项目，然后本地新建文件夹，在文件夹中新建一个Classes文件夹，需要上传的文件放到此文件夹中。<br>cd到Classes上一级目录，git init    git add .   git commit -m “第一版上传”</p><p>git remote add origin XXX</p><p>git push -u origin master</p><p>pod spec create XXX</p><p>修改地址</p><p>git tag ‘xxx’</p><p>git push –tags</p><p>pod trunk push XXXX</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本地Git仓库搭建，小小渣渣给自己Blog留痕，大咖直接忽视，如果错误请指出。谢啦！&lt;/p&gt;
    
    </summary>
    
    
      <category term="-环境搭建" scheme="http://lvjunxue.com/tags/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    
  </entry>
  
  <entry>
    <title>FMDB使用优化</title>
    <link href="http://lvjunxue.com/2016/07/06/FMDB%E4%BD%BF%E7%94%A8/"/>
    <id>http://lvjunxue.com/2016/07/06/FMDB使用/</id>
    <published>2016-07-06T11:05:44.000Z</published>
    <updated>2018-08-16T05:11:16.991Z</updated>
    
    <content type="html"><![CDATA[<p>本地数据库存储，CoreData研究几天，发现一个大问题，虽然可视化，但是它竟然没有自增主键，这我就受不了了，大佬说CoreData很难的，遂卒。反正我就是要弄个小小的本地数据库，改道来了sqlite+FMDB。遂写了一篇文章，来记录过程。</p><a id="more"></a><p>在二次封装FMDB的时候我就蛋疼了一下下，看了下源码FMDatabase和FMDatabaseQueue。这特么是啥？怎么还是两个。通过XX一下，哦哦，soga，一个是可以多线程，一个不可以嘛。</p><p>但是！！！</p><p>嗯，说一下吧，如果你没有看过库表，你要开始使用的时候，你要跳出一个圈，那就是库是库，表是表，他们俩不是一个东西！！！</p><p>等等。。。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本地数据库存储，CoreData研究几天，发现一个大问题，虽然可视化，但是它竟然没有自增主键，这我就受不了了，大佬说CoreData很难的，遂卒。反正我就是要弄个小小的本地数据库，改道来了sqlite+FMDB。遂写了一篇文章，来记录过程。&lt;/p&gt;
    
    </summary>
    
    
      <category term="-OC进阶" scheme="http://lvjunxue.com/tags/OC%E8%BF%9B%E9%98%B6/"/>
    
  </entry>
  
  <entry>
    <title>真机测试如何拿到本地资源</title>
    <link href="http://lvjunxue.com/2016/06/06/%E7%9C%9F%E6%9C%BA%E6%B5%8B%E8%AF%95%E5%A6%82%E4%BD%95%E6%8B%BF%E5%88%B0%E6%9C%AC%E5%9C%B0%E8%B5%84%E6%BA%90/"/>
    <id>http://lvjunxue.com/2016/06/06/真机测试如何拿到本地资源/</id>
    <published>2016-06-06T09:09:32.000Z</published>
    <updated>2018-08-16T05:10:00.892Z</updated>
    
    <content type="html"><![CDATA[<p>Xcode运行真机或虚拟机测试的时候，有一些需要看看本地缓存或者其他的资源，如何查看呢？</p><a id="more"></a><p>来来来，步骤如下：</p><p>Window<br>Devices and Simulators<br>上面选择类型我选择真机Devices<br>INSTALLED APPS下面是不是有一大堆APP，嗯选中你的要查看的APP<br>点击下面设置形状的小图标会有3个选择Download Container，保存到好找的地方，我保存到桌面。<br>你会得到一个XXX.xcappd文件，右键-显示包裹内容。<br>你看到一个AppData文件夹。点进去看看～～～</p><p>GG</p><hr><p>备注：有时候我会突然忘记一点东西，给自己备用，也给一些新人指引。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Xcode运行真机或虚拟机测试的时候，有一些需要看看本地缓存或者其他的资源，如何查看呢？&lt;/p&gt;
    
    </summary>
    
    
      <category term="-OC杂记" scheme="http://lvjunxue.com/tags/OC%E6%9D%82%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>SDWebImage缓存图片更新</title>
    <link href="http://lvjunxue.com/2016/05/05/SDWebImage%E7%BC%93%E5%AD%98%E5%9B%BE%E7%89%87%E6%9B%B4%E6%96%B0/"/>
    <id>http://lvjunxue.com/2016/05/05/SDWebImage缓存图片更新/</id>
    <published>2016-05-05T12:00:00.000Z</published>
    <updated>2018-08-16T05:08:42.182Z</updated>
    
    <content type="html"><![CDATA[<p>我的朋友最近问我SDWebImage缓存的问题，就写了一篇小Blog，记录一下。</p><a id="more"></a><p>首先，打开浏览器，Google一下SDWebImage更新缓存图片。</p><p>嗯嗯，你得到了一个回答，内容大致如下：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dispatch_async</span>(dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>), ^&#123;</span><br><span class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        [<span class="keyword">self</span>.iconView sd_setImageWithURL:[<span class="built_in">NSURL</span> URLWithString:URL(myModel.icon)] placeholderImage:<span class="literal">nil</span> options:SDWebImageRefreshCached];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>SDWebImageRefreshCached看字面意思就是更新缓存嘛，SD的官方也是说用这个方法的啊，看起来很简单嘛，然而事情没有你想的那么简单，你会发现问题如下:</p><p>1、图片没有更新。<br>2、图片没有了。<br>3、XXXXXX等问题。</p><p>仔细看看源码的注解</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (image &amp;&amp; options &amp; SDWebImageRefreshCached) &#123;</span><br><span class="line">    dispatch_main_sync_safe(^&#123;</span><br><span class="line">        <span class="comment">// If image was found in the cache but SDWebImageRefreshCached is provided, notify about the cached image</span></span><br><span class="line">        <span class="comment">// AND try to re-download it in order to let a chance to NSURLCache to refresh it from server.</span></span><br><span class="line">        completedBlock(image, <span class="literal">nil</span>, cacheType, <span class="literal">YES</span>, url);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说是如果缓存中有图片先用，然后图片有更新让NSURLCache从服务器下载新的，来后来我仔细Google一下，服务器需要支持Cache-Control，SDWebImageRefreshCached这个属性才会生效，打开终端，输入 curl 图片url –head 看看有没有Cache-Control:max-age=xxx；如果不存在说明服务不支持，这个xxx就是图片缓存有效时长，设置的时间短呢，很次请求都要去刷新图片，是不是感觉SD的图片缓存的功能似乎没有用了呢。时间长了改变图片不会刷新，很纠结的问题。</p><p>想来想去解决方案有几种方法<br>        1、用SDWebImageCacheMemoryOnly属性，每次大退之后呢，缓存清除了。重新启动后所有图片要重新加载。或者在启动配置分类里写[[SDImageCache sharedImageCache] clearDisk]这个方法是一样的。<br>        2、服务器更换图片加后缀，比如最开始的图片叫1.png，更新图片后改名为1_1.png这样图片的Url改变了，就会重新请求。<br>        3、也是目前比较高逼格的。还是使用SDWebImageRefreshCached属性，需要服务端支持一下下。curl之后拿到如下的结果，发现有ETag和Last-Modified。<br>                HTTP/1.1 200 OK<br>                Server: nginx<br>                Date: Mon, 05 Mar 2018 10:14:57 GMT<br>                Content-Type: image/png;charset=UTF-8<br>                Content-Length: 4469<br>                Connection: keep-alive<br>                Access-Control-Allow-Origin: *<br>                Accept-Ranges: bytes<br>                ETag: W/“4469-1517398918000”<br>                Last-Modified: Wed, 31 Jan 2018 11:41:58 GMT</p><p>网上漫天的贴了一段相同的代码</p><pre><code><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">SDWebImageDownloader *imgDownloader = SDWebImageManager.sharedManager.imageDownloader;</span><br><span class="line"></span><br><span class="line">imgDownloader.headersFilter  = ^<span class="built_in">NSDictionary</span> *(<span class="built_in">NSURL</span> *url, <span class="built_in">NSDictionary</span> *headers) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSFileManager</span> *fm = [[<span class="built_in">NSFileManager</span> alloc] init];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSString</span> *imgKey = [SDWebImageManager.sharedManager cacheKeyForURL:url];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSString</span> *imgPath = [SDWebImageManager.sharedManager.imageCache defaultCachePathForKey:imgKey];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSDictionary</span> *fileAttr = [fm attributesOfItemAtPath:imgPath error:<span class="literal">nil</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSMutableDictionary</span> *mutableHeaders = [headers mutableCopy];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSDate</span> *lastModifiedDate = <span class="literal">nil</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fileAttr.count &gt; <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (fileAttr.count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            lastModifiedDate = (<span class="built_in">NSDate</span> *)fileAttr[<span class="built_in">NSFileModificationDate</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSDateFormatter</span> *formatter = [[<span class="built_in">NSDateFormatter</span> alloc] init];</span><br><span class="line"></span><br><span class="line">    formatter.timeZone = [<span class="built_in">NSTimeZone</span> timeZoneWithAbbreviation:<span class="string">@"GMT"</span>];</span><br><span class="line"></span><br><span class="line">    formatter.locale = [[<span class="built_in">NSLocale</span> alloc] initWithLocaleIdentifier:<span class="string">@"en_US"</span>];</span><br><span class="line"></span><br><span class="line">    formatter.dateFormat = <span class="string">@"EEE, dd MMM yyyy HH:mm:ss z"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSString</span> *lastModifiedStr = [formatter stringFromDate:lastModifiedDate];</span><br><span class="line"></span><br><span class="line">    lastModifiedStr = lastModifiedStr.length &gt; <span class="number">0</span> ? lastModifiedStr : <span class="string">@""</span>;</span><br><span class="line"></span><br><span class="line">    [mutableHeaders setValue:lastModifiedStr forKey:<span class="string">@"If-Modified-Since"</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> mutableHeaders;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></code></pre><p>嗯，加在启动的配置项里。然后你发现你的图片记载并不好使。<br>他们说是需要服务端支持，如果图片有更新返回code200，返回新的ETag和Last-Modified，如果没有更新呢，返回304。<br>SD上面有一段对304的判断：</p><pre><code><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//'304 Not Modified' is an exceptional one</span></span><br><span class="line"><span class="keyword">if</span> (![response respondsToSelector:<span class="keyword">@selector</span>(statusCode)] || ([((<span class="built_in">NSHTTPURLResponse</span> *)response) statusCode] &lt; <span class="number">400</span> &amp;&amp; [((<span class="built_in">NSHTTPURLResponse</span> *)response) statusCode] != <span class="number">304</span>)) &#123;</span><br><span class="line">    <span class="built_in">NSInteger</span> expected = response.expectedContentLength &gt; <span class="number">0</span> ? (<span class="built_in">NSInteger</span>)response.expectedContentLength : <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">self</span>.expectedSize = expected;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.progressBlock) &#123;</span><br><span class="line">        <span class="keyword">self</span>.progressBlock(<span class="number">0</span>, expected);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">self</span>.imageData = [[<span class="built_in">NSMutableData</span> alloc] initWithCapacity:expected];</span><br><span class="line">    <span class="keyword">self</span>.response = response;</span><br><span class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        [[<span class="built_in">NSNotificationCenter</span> defaultCenter] postNotificationName:SDWebImageDownloadReceiveResponseNotification object:<span class="keyword">self</span>];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><p>如果是304，就说明没有新的图片。。。<br>我们服务器估计没有304的判断，所以我也没有做验证，毕竟我是个新手，验证还是要靠你们，晚上8点了，就写这么多了，有问题的话大佬们指出下，我再去重新看一遍。</p><hr>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我的朋友最近问我SDWebImage缓存的问题，就写了一篇小Blog，记录一下。&lt;/p&gt;
    
    </summary>
    
    
      <category term="-OC进阶" scheme="http://lvjunxue.com/tags/OC%E8%BF%9B%E9%98%B6/"/>
    
  </entry>
  
  <entry>
    <title>hexo新建文章操作</title>
    <link href="http://lvjunxue.com/2016/04/28/hexo%E6%96%B0%E5%BB%BA%E6%96%87%E7%AB%A0%E6%93%8D%E4%BD%9C/"/>
    <id>http://lvjunxue.com/2016/04/28/hexo新建文章操作/</id>
    <published>2016-04-28T02:34:25.000Z</published>
    <updated>2018-08-16T05:07:54.257Z</updated>
    
    <content type="html"><![CDATA[<p>个人博客不是经常会用，所以总是忘记Hexo的一些命令，最近重新捡起来，把发布新文章的操作从新纪录一下。</p><a id="more"></a><p>cd 到放置文章的_post目录下<br>创建一篇新文章    hexo new post “xxx”<br>执行发布命令 hexo clean 、 hexo d -g</p><p>上传完成、刷新页面，嗯嗯是不是发现404了。</p><p>CNAME 文件没了，域名指向。</p><p>网上都说创建CNMAE文件不要后缀，怎么创建呢？想了N种方法怕出错，直接终端vim就好了，把文件放到Hexo-blog-source目录下，这样下次就不用重新来生成了。</p><hr><p>以下为本人脑残纪录，跟上述内容无关</p><p>阅读统计：LeanCloud   微博登录的。<br>评论：来必力  手机号还是邮箱的忘掉了。<br>图片：七牛云上配置   应该诗手记。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;个人博客不是经常会用，所以总是忘记Hexo的一些命令，最近重新捡起来，把发布新文章的操作从新纪录一下。&lt;/p&gt;
    
    </summary>
    
    
      <category term="-hexo记录" scheme="http://lvjunxue.com/tags/hexo%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>C++创建新类如何关联到main.cpp上</title>
    <link href="http://lvjunxue.com/2016/04/15/C-%E5%88%9B%E5%BB%BA%E6%96%B0%E7%B1%BB%E5%A6%82%E4%BD%95%E5%85%B3%E8%81%94%E5%88%B0main-cpp%E4%B8%8A/"/>
    <id>http://lvjunxue.com/2016/04/15/C-创建新类如何关联到main-cpp上/</id>
    <published>2016-04-15T07:53:47.000Z</published>
    <updated>2018-08-16T05:08:06.824Z</updated>
    
    <content type="html"><![CDATA[<p>对于无C++基础的人来说，新建一个.h和.cpp如何与main.cpp关联是一脸懵逼的状态。</p><a id="more"></a><p>本人用mac的Xcode来学习C++的，所以创建的.hpp与.h是一个东西<br>首先创建一个新类LJX_One.hpp和LJX_One.cpp</p><p>LJX_One.hpp代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> LJX_One_hpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LJX_One_hpp</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LJX</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        LJX()&#123;&#125;;</span><br><span class="line">        ~LJX()&#123;&#125;;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">sort</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">compact</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* LJX_One_hpp */</span></span></span><br></pre></td></tr></table></figure><p>LJX_One.cpp代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"LJX_One.hpp"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> LJX::sort()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> LJX::compact()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> ljx_count = <span class="number">1024</span>;</span><br><span class="line">    <span class="keyword">int</span> * ljx_isa = &amp;ljx_count;</span><br><span class="line">    *ljx_isa = *ljx_isa + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ljx_count;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt;<span class="string">"\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> LJX::write()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> *pi = <span class="keyword">new</span> <span class="keyword">int</span>( <span class="number">0</span> );</span><br><span class="line">    <span class="keyword">int</span> *pia = <span class="keyword">new</span> <span class="keyword">int</span>[ <span class="number">10</span> ];</span><br><span class="line">    <span class="keyword">while</span> ( *pi &lt; <span class="number">10</span> ) &#123;</span><br><span class="line">        pia[ *pi ] = *pi;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; pia[ *pi ] &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">        *pi = *pi + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span> pi;</span><br><span class="line">    <span class="keyword">delete</span> [] pia;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>main.cpp中调用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"LJX_One.hpp"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">LJX first;</span><br><span class="line"><span class="keyword">int</span> count = first.sort();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">    first.compact();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    first.write();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;对于无C++基础的人来说，新建一个.h和.cpp如何与main.cpp关联是一脸懵逼的状态。&lt;/p&gt;
    
    </summary>
    
    
      <category term="-C++初探" scheme="http://lvjunxue.com/tags/C-%E5%88%9D%E6%8E%A2/"/>
    
  </entry>
  
  <entry>
    <title>开始写博客</title>
    <link href="http://lvjunxue.com/2016/03/05/%E5%BC%80%E5%A7%8B%E5%86%99%E5%8D%9A%E5%AE%A2/"/>
    <id>http://lvjunxue.com/2016/03/05/开始写博客/</id>
    <published>2016-03-05T09:00:00.000Z</published>
    <updated>2018-08-16T05:09:32.591Z</updated>
    
    <content type="html"><![CDATA[<p>Blog。</p><a id="more"></a><p>个人感觉，现在的Github上em。。。所以现在很少上Github上down代码来看，都是在Stackoverflow瞎逛。</p><p>以前很多东西都是放在脑子里的，出现问题会微微的有一点印象，随便Google下，就可以了。最近工作不是那么稳定，有点想去大佬的地方呆呆，学习一点东西的想法。所以重拾个人博客，至于Github，自己搭建过很多的框架，每次都不满意，最近又开始新的旅程。等我在自己的水平上，搭建完自己满意的东西，会把平时用的都搞上去，然后在上传。亲们，我只是一个小渣渣，不好的地方请不要打我，先行谢过！！！</p><hr>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Blog。&lt;/p&gt;
    
    </summary>
    
    
      <category term="-杂记" scheme="http://lvjunxue.com/tags/%E6%9D%82%E8%AE%B0/"/>
    
  </entry>
  
</feed>
